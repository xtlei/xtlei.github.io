<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>蟹家之宝树</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xtlei.github.io/"/>
  <updated>2020-04-25T04:01:25.861Z</updated>
  <id>https://xtlei.github.io/</id>
  
  <author>
    <name>XTLei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python类和实例—类和实例的属性及方法</title>
    <link href="https://xtlei.github.io/2020/04/25/Python%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E2%80%94%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%8A%E6%96%B9%E6%B3%95/"/>
    <id>https://xtlei.github.io/2020/04/25/Python%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E2%80%94%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%8A%E6%96%B9%E6%B3%95/</id>
    <published>2020-04-25T03:45:19.128Z</published>
    <updated>2020-04-25T04:01:25.861Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><h4 id="类属性和实例属性区别"><a href="#类属性和实例属性区别" class="headerlink" title="类属性和实例属性区别"></a>类属性和实例属性区别</h4><p><strong>类是模板，而实例则是根据类创建的对象</strong>。<a id="more"></a><br>绑定在一个实例上的属性不会影响其他实例，但是，类本身也是一个对象，如果在类上绑定一个属性，则所有实例都可以访问类的属性，并且，所有实例访问的类属性都是同一个！也就是说，<strong>实例属性每个实例各自拥有，互相独立，而类属性有且只有一份，所有实例共同拥有</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义类属性可以直接在class中定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    address = <span class="string">'Earth'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"><span class="comment"># 因为类属性是直接绑定在类上的，所以，访问类属性不需要创建实例，就可以直接访问</span></span><br><span class="line"><span class="keyword">print</span> Person.address  <span class="comment"># =&gt; Earth</span></span><br><span class="line"><span class="comment"># 对一个实例调用类的属性也是可以访问的，所有实例都可以访问到它所属的类的属性</span></span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>)</span><br><span class="line">p2 = Person(<span class="string">'Alice'</span>)</span><br><span class="line"><span class="keyword">print</span> p1.address  <span class="comment"># =&gt; Earth</span></span><br><span class="line"><span class="keyword">print</span> p2.address  <span class="comment"># =&gt; Earth</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类属性也是可以动态添加和修改的</span></span><br><span class="line"><span class="comment">#因为类属性只有一份，所以，当Person类的address改变时，所有实例访问到的类属性都改变了</span></span><br><span class="line">Person.address = <span class="string">'China'</span></span><br><span class="line"><span class="keyword">print</span> p1.address  <span class="comment"># =&gt; 'China'</span></span><br><span class="line"><span class="keyword">print</span> p2.address  <span class="comment"># =&gt; 'China'</span></span><br></pre></td></tr></table></figure><h4 id="类属性和实例属性冲突"><a href="#类属性和实例属性冲突" class="headerlink" title="类属性和实例属性冲突"></a>类属性和实例属性冲突</h4><p>修改类属性会导致所有实例访问到的类属性全部都受影响，但是，如果在实例变量上修改类属性会发生什么问题呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    address = <span class="string">'Earth'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>)</span><br><span class="line">p2 = Person(<span class="string">'Alice'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Person.address = '</span> + Person.address</span><br><span class="line"></span><br><span class="line">p1.address = <span class="string">'China'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'p1.address = '</span> + p1.address</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Person.address = '</span> + Person.address</span><br><span class="line"><span class="keyword">print</span> <span class="string">'p2.address = '</span> + p2.address</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果如下：</span></span><br><span class="line">Person.address = Earth</span><br><span class="line">p1.address = China</span><br><span class="line">Person.address = Earth</span><br><span class="line">p2.address = Earth</span><br></pre></td></tr></table></figure><p>在设置了p1.address = ‘China’后，p1访问address确实变成了’China’，但是，Person.address和p2.address仍然是’Earch’。原因是p1.address = ‘China’并没有改变Person的address，而是给p1这个实例绑定了实例属性address，对p1来说，它有一个实例属性address（值是’China’），而它所属的类Person也有一个类属性address，所以:<br>访问p1.address时，优先查找实例属性，返回’China’。<br>访问p2.address时，p2没有实例属性address，但是有类属性address，因此返回’Earth’。<br>可见，当实例属性和类属性重名时，实例属性优先级高，它将屏蔽掉对类属性的访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当p1的address实例属性删除后，p1.address就又返回类属性的值'Earth'了：</span></span><br><span class="line"><span class="keyword">del</span> p1.address</span><br><span class="line"><span class="keyword">print</span> p1.address  <span class="comment"># =&gt; Earth</span></span><br></pre></td></tr></table></figure><p>可见，千万不要在实例上修改类属性，它实际上并没有修改类属性，而是给实例绑定了一个实例属性。</p><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>虽然私有属性无法从外部访问，但是，从类的内部是可以访问的。除了可以定义实例的属性外，还可以定义实例的方法。<br><strong>实例方法就是在类中定义的函数，它的第一个参数永远是self，指向调用该方法的实例本身，其他参数和一个普通函数是完全一样的</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br></pre></td></tr></table></figure><p>get_name(self)就是一个实例方法，它的第一个参数是self。<strong>init</strong>(self, name)其实也可看做是一个特殊的实例方法。<br>调用实例方法必须在实例上调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1 = Person(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="keyword">print</span> p1.get_name()  <span class="comment"># self不需要显式传入</span></span><br><span class="line"><span class="comment"># =&gt; Bob</span></span><br></pre></td></tr></table></figure><p>在实例方法内部，可以访问所有实例属性，这样，如果外部需要访问私有属性，可以通过方法调用获得，这种数据封装的形式除了能保护内部数据一致性外，还可以简化外部调用的难度。</p><h4 id="方法也是属性"><a href="#方法也是属性" class="headerlink" title="方法也是属性"></a>方法也是属性</h4><p>在class中定义的实例方法其实也是属性，它实际上是一个函数对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'A'</span></span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>, <span class="number">90</span>)</span><br><span class="line"><span class="keyword">print</span> p1.get_grade  <span class="comment"># =&gt; &lt;bound method Person.get_grade of &lt;__main__.Person object at 0x109e58510&gt;&gt;</span></span><br><span class="line"><span class="keyword">print</span> p1.get_grade()  <span class="comment"># =&gt; A</span></span><br></pre></td></tr></table></figure><p>也就是说，p1.get_grade返回的是一个函数对象，但这个函数是一个绑定到实例的函数，p1.get_grade()才是方法调用。<br>因为方法也是一个属性，所以，它也可以动态地添加到实例上，只是需要用types.MethodType()把一个函数变为一个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn_get_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.score &gt;= <span class="number">80</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'A'</span></span><br><span class="line">    <span class="keyword">if</span> self.score &gt;= <span class="number">60</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'B'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'C'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>, <span class="number">90</span>)</span><br><span class="line">p1.get_grade = types.MethodType(fn_get_grade, p1, Person)</span><br><span class="line"><span class="keyword">print</span> p1.get_grade()  <span class="comment"># =&gt; A</span></span><br><span class="line">p2 = Person(<span class="string">'Alice'</span>, <span class="number">65</span>)</span><br><span class="line"><span class="keyword">print</span> p2.get_grade()  <span class="comment"># ERROR: AttributeError: 'Person' object has no attribute 'get_grade'</span></span><br><span class="line"><span class="comment"># 因为p2实例并没有绑定get_grade</span></span><br></pre></td></tr></table></figure><p>给一个实例动态添加方法并不常见，直接在class中定义要更直观。</p><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>在class中定义的全部是实例方法，实例方法第一个参数self是实例本身。<br>要在class中定义类方法，需要这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">how_many</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.count</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        Person.count = Person.count + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> Person.how_many()</span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="keyword">print</span> Person.how_many()</span><br></pre></td></tr></table></figure><p><strong>通过标记一个@classmethod，该方法将绑定到Person类上，而非类的实例</strong>。类方法的第一个参数将传入类本身，通常将参数名命名为cls，上面的cls.count实际上相当于Person.count。<br>因为是在类上调用，而非实例上调用，因此类方法无法获得任何实例变量，只能获得类的引用。<br></p></font><p></p></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;h4 id=&quot;类属性和实例属性区别&quot;&gt;&lt;a href=&quot;#类属性和实例属性区别&quot; class=&quot;headerlink&quot; title=&quot;类属性和实例属性区别&quot;&gt;&lt;/a&gt;类属性和实例属性区别&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;类是模板，而实例则是根据类创建的对象&lt;/strong&gt;。&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="软件开发" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="Advan" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Advan/"/>
    
      <category term="Object-oriented" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Advan/Object-oriented/"/>
    
    
      <category term="Python进阶" scheme="https://xtlei.github.io/tags/Python%E8%BF%9B%E9%98%B6/"/>
    
      <category term="面向对象" scheme="https://xtlei.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="类方法" scheme="https://xtlei.github.io/tags/%E7%B1%BB%E6%96%B9%E6%B3%95/"/>
    
      <category term="实例方法" scheme="https://xtlei.github.io/tags/%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/"/>
    
      <category term="类属性" scheme="https://xtlei.github.io/tags/%E7%B1%BB%E5%B1%9E%E6%80%A7/"/>
    
      <category term="实例属性" scheme="https://xtlei.github.io/tags/%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python类和实例—类的定义和实例创建</title>
    <link href="https://xtlei.github.io/2020/04/25/Python%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E2%80%94%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA/"/>
    <id>https://xtlei.github.io/2020/04/25/Python%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E2%80%94%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA/</id>
    <published>2020-04-25T03:16:11.181Z</published>
    <updated>2020-04-25T03:45:13.280Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><h4 id="面向对象编程简介"><a href="#面向对象编程简介" class="headerlink" title="面向对象编程简介"></a>面向对象编程简介</h4><p>面向对象编程是一种程序设计范式，把程序看做不同对象的相互调用，对现实世界建立对象模型。<a id="more"></a><br><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py14-1.png" alt=" "></p><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py14-2.png" alt=" "></p><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py14-3.png" alt=" "></p><h4 id="定义类并创建实例"><a href="#定义类并创建实例" class="headerlink" title="定义类并创建实例"></a>定义类并创建实例</h4><h5 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h5><p>在Python中，类通过class关键字定义。以Person为例，定义一个Person类如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>按照Python的编程习惯，类名以大写字母开头，紧接着是(object)，表示该类是从哪个类继承下来的。<br>有了Person类的定义，就可以创建出具体的xiaoming、xiaohong等实例。创建实例使用类名+()，类似函数调用的形式创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xiaoming = Person()</span><br><span class="line">xiaohong = Person()</span><br></pre></td></tr></table></figure><h5 id="创建实例属性"><a href="#创建实例属性" class="headerlink" title="创建实例属性"></a>创建实例属性</h5><p>虽然可以通过Person类创建出xiaoming、xiaohong等实例，但是这些实例看上除了地址不同外，没有什么其他不同。在现实世界中，区分xiaoming、xiaohong要依靠他们各自的名字、性别、生日等属性。<br>如何让每个实例拥有各自不同的属性？由于Python是动态语言，对每一个实例，都可以直接给他们的属性赋值，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给xiaoming加上name、gender和birth属性</span></span><br><span class="line">xiaoming = Person()</span><br><span class="line">xiaoming.name = <span class="string">'Xiao Ming'</span></span><br><span class="line">xiaoming.gender = <span class="string">'Male'</span></span><br><span class="line">xiaoming.birth = <span class="string">'1990-1-1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给xiaohong加上的属性不一定要和xiaoming相同</span></span><br><span class="line">xiaohong = Person()</span><br><span class="line">xiaohong.name = <span class="string">'Xiao Hong'</span></span><br><span class="line">xiaohong.school = <span class="string">'No. 1 High School'</span></span><br><span class="line">xiaohong.grade = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>实例的属性可以像普通变量一样进行操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xiaohong.grade = xiaohong.grade + <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="初始化实例属性"><a href="#初始化实例属性" class="headerlink" title="初始化实例属性"></a>初始化实例属性</h4><p>在定义Person类时，可以为Person类添加一个特殊的__init__()方法，当创建实例时，__init__()方法被自动调用，就能在此为每个实例都统一加上以下属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, birth)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.birth = birth</span><br></pre></td></tr></table></figure><p>__init__()方法的第一个参数必须是self（也可以用别的名字，但建议使用习惯用法），后续参数则可以自由指定，和定义函数没有任何区别。<br>相应地，创建实例时，就必须要提供除self以外的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xiaoming = Person(<span class="string">'Xiao Ming'</span>, <span class="string">'Male'</span>, <span class="string">'1991-1-1'</span>)</span><br><span class="line">xiaohong = Person(<span class="string">'Xiao Hong'</span>, <span class="string">'Female'</span>, <span class="string">'1992-2-2'</span>)</span><br></pre></td></tr></table></figure><p>有了__init__()方法，每个Person实例在创建时，都会有name、gender和birth这3个属性，并且，被赋予不同的属性值，访问属性使用“.”操作符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> xiaoming.name  <span class="comment"># 输出 'Xiao Ming'</span></span><br><span class="line"><span class="keyword">print</span> xiaohong.birth  <span class="comment"># 输出 '1992-2-2'</span></span><br></pre></td></tr></table></figure><p>要特别注意的是，定义__init__()方法一定不能忘记self参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(name, gender, birth)</span>:</span></span><br><span class="line">         <span class="keyword">pass</span></span><br><span class="line">xiaoming = Person(<span class="string">'Xiao Ming'</span>, <span class="string">'Male'</span>, <span class="string">'1990-1-1'</span>)</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: __init__() takes exactly <span class="number">3</span> arguments (<span class="number">4</span> given)</span><br></pre></td></tr></table></figure><p>这会导致创建失败或运行不正常，因为第一个参数name被Python解释器传入了实例的引用，从而导致整个方法的调用参数位置全部没有对上。</p><p>接受任意关键字参数，允许把其作为属性赋值给实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,gender,birth,**kw)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.birth = birth</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> kw.items():</span><br><span class="line">            setattr(self,k,v)</span><br><span class="line"></span><br><span class="line">xiaoming = Person(<span class="string">'Xiao Ming'</span>, <span class="string">'Male'</span>, <span class="string">'1990-1-1'</span>, job=<span class="string">'Student'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> xiaoming.name</span><br><span class="line"><span class="keyword">print</span> xiaoming.job</span><br></pre></td></tr></table></figure><h4 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h4><p><strong>Python对属性权限的控制是通过属性名来实现的，如果一个属性由双下划线开头(__)，该属性就无法被外部访问</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self._title = <span class="string">'Mr'</span></span><br><span class="line">        self.__job = <span class="string">'Student'</span></span><br><span class="line">p = Person(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="keyword">print</span> p.name  <span class="comment"># =&gt; Bob</span></span><br><span class="line"><span class="keyword">print</span> p._title  <span class="comment"># =&gt; Mr</span></span><br><span class="line"><span class="keyword">print</span> p.__job  <span class="comment"># =&gt; Error</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'Person'</span> object has no attribute <span class="string">'__job'</span></span><br></pre></td></tr></table></figure><p>可见，只有以双下划线开头的&quot;__job&quot;不能直接被外部访问。<br>但是，<strong>如果一个属性以&quot;__xxx__&quot;的形式定义，那它又可以被外部访问了，以&quot;__xxx__&quot;定义的属性在Python的类中被称为特殊属性，有很多预定义的特殊属性可以使用，通常不要把普通属性用&quot;__xxx__&quot;定义</strong>。<br><strong>以单下划线开头的属性&quot;_xxx&quot;虽然也可以被外部访问，但是，按照习惯，它们不应该被外部访问</strong>。<br></p></font><p></p></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;h4 id=&quot;面向对象编程简介&quot;&gt;&lt;a href=&quot;#面向对象编程简介&quot; class=&quot;headerlink&quot; title=&quot;面向对象编程简介&quot;&gt;&lt;/a&gt;面向对象编程简介&lt;/h4&gt;&lt;p&gt;面向对象编程是一种程序设计范式，把程序看做不同对象的相互调用，对现实世界建立对象模型。&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="软件开发" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="Advan" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Advan/"/>
    
      <category term="Object-oriented" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Advan/Object-oriented/"/>
    
    
      <category term="Python进阶" scheme="https://xtlei.github.io/tags/Python%E8%BF%9B%E9%98%B6/"/>
    
      <category term="面向对象" scheme="https://xtlei.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="类的定义" scheme="https://xtlei.github.io/tags/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89/"/>
    
      <category term="实例创建" scheme="https://xtlei.github.io/tags/%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA/"/>
    
      <category term="初始化实例" scheme="https://xtlei.github.io/tags/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%9E%E4%BE%8B/"/>
    
      <category term="权限控制" scheme="https://xtlei.github.io/tags/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Python文件读写</title>
    <link href="https://xtlei.github.io/2020/04/25/Python%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <id>https://xtlei.github.io/2020/04/25/Python%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</id>
    <published>2020-04-25T02:42:48.670Z</published>
    <updated>2020-04-25T03:19:09.866Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><h4 id="文件内容读取"><a href="#文件内容读取" class="headerlink" title="文件内容读取"></a>文件内容读取</h4><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py13-9.png" alt=" "></p><a id="more"></a><p>&lt;f&gt;.readline(size=-1) 读入文件一行，如果给定参数，输出文件前size行内容<br><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py13-10.png" alt=" "></p><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py13-11.png" alt=" "></p><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py13-12.png" alt=" "></p><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py13-13.png" alt=" "></p><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py13-14.png" alt=" "></p><h4 id="文件内容写入"><a href="#文件内容写入" class="headerlink" title="文件内容写入"></a>文件内容写入</h4><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py13-15.png" alt=" "></p><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py13-16.png" alt=" "></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fo = open(<span class="string">"D:/test.txt"</span>, <span class="string">"w+"</span>)</span><br><span class="line">list = [<span class="string">'中国'</span>, <span class="string">'法国'</span>, <span class="string">'美国'</span>]</span><br><span class="line">fo.writelines(list)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fo:</span><br><span class="line">    print(line)</span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure><p>以上代码，创建文件test.txt，并写入内容“中国法国美国”，但是没有读取文件内容。因为在向文件写入数据后，文件操作指针移动到文件末尾，而读取文件操作是读取从指针当前位置到文件末尾的内容，所以读取不到内容。使用seek()函数，改变当前指针位置到文件开头，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fo = open(<span class="string">"D:/test.txt"</span>, <span class="string">"w+"</span>)</span><br><span class="line">list = [<span class="string">'中国'</span>, <span class="string">'法国'</span>, <span class="string">'美国'</span>]</span><br><span class="line">fo.writelines(list)</span><br><span class="line">fo.seek(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fo:</span><br><span class="line">    print(line)</span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure><h4 id="数据的表示和处理"><a href="#数据的表示和处理" class="headerlink" title="数据的表示和处理"></a>数据的表示和处理</h4><h5 id="一维数据格式化处理"><a href="#一维数据格式化处理" class="headerlink" title="一维数据格式化处理"></a>一维数据格式化处理</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fo = open(<span class="string">"D:/test.txt"</span>, <span class="string">"w+"</span>)</span><br><span class="line">list = [<span class="string">'中国'</span>, <span class="string">'法国'</span>, <span class="string">'美国'</span>]</span><br><span class="line">fo.writelines(list)</span><br><span class="line">fo.seek(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fo:</span><br><span class="line">    print(line)</span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure><h5 id="二维数据格式化处理"><a href="#二维数据格式化处理" class="headerlink" title="二维数据格式化处理"></a>二维数据格式化处理</h5><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py13-17.png" alt=" "></p><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py13-18.png" alt=" "></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从csv文件中读取二维数据存储到二维列表中</span></span><br><span class="line">fo = open(<span class="string">"test.txt"</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">ls = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fo</span><br><span class="line">    line = line.replace(<span class="string">"\n"</span>, <span class="string">''</span>)</span><br><span class="line">    ls.append(line.split(<span class="string">","</span>))</span><br><span class="line">fo.close()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将列表中的二维数据写入到csv格式的文件中</span></span><br><span class="line">ls = [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">fo = open(<span class="string">"test.txt"</span>, <span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> ls:</span><br><span class="line">    f.write(<span class="string">","</span>.join(item) + <span class="string">'\n'</span>)</span><br><span class="line">fo.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数据的遍历</span></span><br><span class="line">ls = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ls:</span><br><span class="line">    print(row)</span><br><span class="line">    <span class="keyword">for</span> column <span class="keyword">in</span> row:</span><br><span class="line">        print(column)</span><br></pre></td></tr></table></figure></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;h4 id=&quot;文件内容读取&quot;&gt;&lt;a href=&quot;#文件内容读取&quot; class=&quot;headerlink&quot; title=&quot;文件内容读取&quot;&gt;&lt;/a&gt;文件内容读取&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py13-9.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="软件开发" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="Advan" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Advan/"/>
    
      <category term="File &amp; Data" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Advan/File-Data/"/>
    
    
      <category term="Python进阶" scheme="https://xtlei.github.io/tags/Python%E8%BF%9B%E9%98%B6/"/>
    
      <category term="文件读取" scheme="https://xtlei.github.io/tags/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    
      <category term="文件写入" scheme="https://xtlei.github.io/tags/%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5/"/>
    
      <category term="数据格式化处理" scheme="https://xtlei.github.io/tags/%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python文件打开和关闭</title>
    <link href="https://xtlei.github.io/2020/04/25/Python%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD/"/>
    <id>https://xtlei.github.io/2020/04/25/Python%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD/</id>
    <published>2020-04-25T02:16:51.727Z</published>
    <updated>2020-04-25T03:19:01.371Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><h4 id="文件的理解"><a href="#文件的理解" class="headerlink" title="文件的理解"></a>文件的理解</h4><p>文件是数据的抽象和集合，是存储在辅助存储器上的数据序列，是数据存储的一种形式。<a id="more"></a><br><strong>文件展现形态：文本文件和二进制文件</strong>。<br><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py13-1.png" alt=" "></p><p><strong>文本文件</strong>：由单一特定编码组成的文件，如UTF-8编码；由于存在编码，也被看成是存储着的长字符串；适用于例如：.txt文件、.py文件等。<br><strong>二进制文件</strong>：直接由比特0和1组成，没有统一的字符编码；一般存在二进制0和1的组织结构，即文件格式；适用于例如：.png文件、.avi文件等。</p><h4 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h4><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py13-4.png" alt=" "></p><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py13-5.png" alt=" "></p><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py13-6.png" alt=" "></p><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py13-7.png" alt=" "></p><p><strong>文件关闭：&lt;变量名&gt;.close()</strong><br>注意调用close()方法将文件及时关闭，如果没有关闭，Python在程序正常关闭时也会关闭文件。</p></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;h4 id=&quot;文件的理解&quot;&gt;&lt;a href=&quot;#文件的理解&quot; class=&quot;headerlink&quot; title=&quot;文件的理解&quot;&gt;&lt;/a&gt;文件的理解&lt;/h4&gt;&lt;p&gt;文件是数据的抽象和集合，是存储在辅助存储器上的数据序列，是数据存储的一种形式。&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="软件开发" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="Advan" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Advan/"/>
    
      <category term="File &amp; Data" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Advan/File-Data/"/>
    
    
      <category term="Python进阶" scheme="https://xtlei.github.io/tags/Python%E8%BF%9B%E9%98%B6/"/>
    
      <category term="文件打开" scheme="https://xtlei.github.io/tags/%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80/"/>
    
      <category term="文件关闭" scheme="https://xtlei.github.io/tags/%E6%96%87%E4%BB%B6%E5%85%B3%E9%97%AD/"/>
    
  </entry>
  
  <entry>
    <title>Python列表生成式</title>
    <link href="https://xtlei.github.io/2020/03/31/Python%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F/"/>
    <id>https://xtlei.github.io/2020/03/31/Python%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F/</id>
    <published>2020-03-31T14:12:07.840Z</published>
    <updated>2020-04-24T14:30:16.031Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><p>要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，可以用range(1, 11)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>range(<span class="number">1</span>, <span class="number">11</span>)  <span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>但如果要生成[1x1, 2x2, 3x3, …, 10x10]方法一是循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    L.append(x * x)</span><br><span class="line">print(L)  <span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span></span><br></pre></td></tr></table></figure><p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print([x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)])  <span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span></span><br></pre></td></tr></table></figure><p>这种写法就是Python特有的列表生成式。利用列表生成式，可以以简洁的代码生成list。写列表生成式时，把要生成的元素x*x放到前面，后面跟for循环，就可以把list创建出来。</p><h5 id="复杂表达式"><a href="#复杂表达式" class="headerlink" title="复杂表达式"></a>复杂表达式</h5><p>使用for循环的迭代不仅可以迭代普通的list，还可以迭代dict。比如一个dict如下，可以通过一个复杂的列表生成式把它变成一个HTML表格，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = &#123; <span class="string">'Adam'</span>: <span class="number">95</span>, <span class="string">'Lisa'</span>: <span class="number">85</span>, <span class="string">'Bart'</span>: <span class="number">59</span> &#125;</span><br><span class="line">tds = [<span class="string">'&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;'</span> % (name, score) <span class="keyword">for</span> name, score <span class="keyword">in</span> d.iteritems()]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'&lt;table&gt;'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'\n'</span>.join(tds)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'&lt;/table&gt;'</span></span><br></pre></td></tr></table></figure><p>注：字符串可以通过%进行格式化，用指定的参数替代%s。字符串的join()方法可以把一个list拼接成一个字符串。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>Score<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Lisa<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>85<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Adam<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>95<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Bart<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>59<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将以上打印出来的结果保存为一个html文件，就可以在浏览器中看到效果了：<br><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py12-1.png" alt=" "></p><h5 id="条件过滤"><a href="#条件过滤" class="headerlink" title="条件过滤"></a>条件过滤</h5><p>列表生成式的for循环后面还可以加上if判断。如上平方的列表生成式，如果只想要偶数的平方，不改动range()的情况下，可以加上if来筛选，有了if条件，只有if判断为True的时候，才把循环的当前元素添加到列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print([x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>])  <span class="comment"># [4, 16, 36, 64, 100]</span></span><br></pre></td></tr></table></figure><h5 id="多层表达式"><a href="#多层表达式" class="headerlink" title="多层表达式"></a>多层表达式</h5><p>for循环可以嵌套，因此，在列表生成式中，也可以用多层for循环来生成列表。<br>对于字符串’ABC’和’123’，可以使用两层循环，生成全排列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print([m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'123'</span>])</span><br><span class="line"><span class="comment"># ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span>:</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'123'</span>:</span><br><span class="line">        L.append(m + n)</span><br><span class="line">print(L)</span><br></pre></td></tr></table></figure></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;p&gt;要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，可以用range(1, 11)：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;range(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="软件开发" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="Basis" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Basis/"/>
    
    
      <category term="Python基础" scheme="https://xtlei.github.io/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
      <category term="列表生成式" scheme="https://xtlei.github.io/tags/%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python中迭代</title>
    <link href="https://xtlei.github.io/2020/03/31/Python%E8%BF%AD%E4%BB%A3/"/>
    <id>https://xtlei.github.io/2020/03/31/Python%E8%BF%AD%E4%BB%A3/</id>
    <published>2020-03-31T14:05:23.693Z</published>
    <updated>2020-04-25T09:12:43.356Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><p>在Python中，如果给定一list或tuple，通过for循环可以遍历，这种遍历称为迭代（Iteration）。<br>Python的for循环可以作用在任何可迭代对象上。因此，迭代操作就是对于一个集合，无论该集合是有序还是无序，用for循环总是可以依次取出集合的每一个元素。<a id="more"></a></p><p>注意：集合是指包含一组元素的数据结构，包括：<br><strong>1.有序集合：list，tuple，str和unicode；<br>2.无序集合：set<br>3.无序集合并且具有key-value对：dict</strong><br>而迭代是一个动词，是一种操作，在Python中就是指for循环。<br>迭代与按下标访问数组最大的不同是，后者是一种具体的迭代实现方式，而前者只关心迭代结果，根本不关心迭代内部是如何实现的。</p><h5 id="索引迭代"><a href="#索引迭代" class="headerlink" title="索引迭代"></a>索引迭代</h5><p>Python中，迭代永远是取出元素本身，而非元素的索引。<br>对于有序集合，元素确实是有索引的。有时需要在for循环中拿到索引，方法是使用enumerate()函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>, <span class="string">'Paul'</span>]</span><br><span class="line"><span class="keyword">for</span> index, name <span class="keyword">in</span> enumerate(L):</span><br><span class="line">    <span class="keyword">print</span> index, <span class="string">'-'</span>, name</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> - Adam</span><br><span class="line"><span class="number">1</span> - Lisa</span><br><span class="line"><span class="number">2</span> - Bart</span><br><span class="line"><span class="number">3</span> - Paul</span><br></pre></td></tr></table></figure><p>使用enumerate()函数，可以在for循环中同时绑定索引index和元素name。实际上，enumerate()函数把：[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]变成了类似：[(0, &#39;Adam&#39;), (1, &#39;Lisa&#39;), (2, &#39;Bart&#39;), (3, &#39;Paul&#39;)]。因此，迭代的每一个元素实际上是一个tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> enumerate(L):</span><br><span class="line">    index = t[<span class="number">0</span>]</span><br><span class="line">    name = t[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">print</span> index, <span class="string">'-'</span>, name</span><br></pre></td></tr></table></figure><p>可见，索引迭代也不是真的按索引访问，而是由<strong>enumerate() 函数自动把每个元素变成(index, element)这样的tuple</strong>，再迭代，就同时获得了索引和元素本身。</p><h5 id="迭代dict的value"><a href="#迭代dict的value" class="headerlink" title="迭代dict的value"></a>迭代dict的value</h5><p>dict对象本身就是可迭代对象，用for循环直接迭代dict，可以每次拿到dict的一个key。<br>如果迭代dict对象的value，dict对象有一个values()方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是dict的每一个value：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d = &#123; <span class="string">'Adam'</span>: <span class="number">95</span>, <span class="string">'Lisa'</span>: <span class="number">85</span>, <span class="string">'Bart'</span>: <span class="number">59</span> &#125;</span><br><span class="line"><span class="keyword">print</span> d.values()  <span class="comment"># [85, 95, 59]</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> d.values():</span><br><span class="line">    <span class="keyword">print</span> v</span><br><span class="line"><span class="comment"># 85</span></span><br><span class="line"><span class="comment"># 95</span></span><br><span class="line"><span class="comment"># 59</span></span><br></pre></td></tr></table></figure><p>dict除了values()方法外，还有一个itervalues()方法，用itervalues()方法替代values()方法，迭代效果完全一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> d.itervalues()</span><br><span class="line"><span class="comment"># &lt;dictionary-valueiterator object at 0x106adbb50&gt;</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> d.itervalues():</span><br><span class="line">         <span class="keyword">print</span> v</span><br><span class="line"><span class="comment"># 85</span></span><br><span class="line"><span class="comment"># 95</span></span><br><span class="line"><span class="comment"># 59</span></span><br></pre></td></tr></table></figure><p>这两个方法区别：<br>1.values()方法实际上把一个dict转换成了包含value的list。<br>2.但是itervalues()方法不会转换，它会在迭代过程中依次从dict中取出 value，所以itervalues()方法比values()方法节省了生成list所需的内存。<br>3.打印itervalues()发现它返回一个<dictionary-valueiterator>对象，这说明在Python中，for循环可作用的迭代对象远不止list，tuple，str，unicode，dict等，任何可迭代对象都可以作用于for循环，而内部如何迭代通常并不用关心。</dictionary-valueiterator></p><p>如果一个对象可迭代，那就直接用for循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。</p><h5 id="迭代dict的key和value"><a href="#迭代dict的key和value" class="headerlink" title="迭代dict的key和value"></a>迭代dict的key和value</h5><p>items()方法把dict对象转换成了包含tuple的list，对这个list进行迭代，可以同时获得key和value：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="keyword">print</span> key, <span class="string">':'</span>, value</span><br><span class="line"></span><br><span class="line">Lisa : <span class="number">85</span></span><br><span class="line">Adam : <span class="number">95</span></span><br><span class="line">Bart : <span class="number">59</span></span><br></pre></td></tr></table></figure><p>类似values()对应itervalues()，items()也有对应的iteritems()，iteritems()不把dict转换成list，而是在迭代过程中不断给出tuple，所以，iteritems()不占用额外的内存。</p></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;p&gt;在Python中，如果给定一list或tuple，通过for循环可以遍历，这种遍历称为迭代（Iteration）。&lt;br&gt;Python的for循环可以作用在任何可迭代对象上。因此，迭代操作就是对于一个集合，无论该集合是有序还是无序，用for循环总是可以依次取出集合的每一个元素。&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="软件开发" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="Basis" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Basis/"/>
    
    
      <category term="Python基础" scheme="https://xtlei.github.io/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
      <category term="迭代" scheme="https://xtlei.github.io/tags/%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>Python切片操作</title>
    <link href="https://xtlei.github.io/2020/03/31/Python%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C/"/>
    <id>https://xtlei.github.io/2020/03/31/Python%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C/</id>
    <published>2020-03-31T14:00:27.805Z</published>
    <updated>2020-04-24T13:50:00.981Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><h5 id="list切片"><a href="#list切片" class="headerlink" title="list切片"></a>list切片</h5><p>Python提供了切片（Slice）操作符“<strong>:</strong>”，简化取指定索引范围的操作。<br>L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]取前3个元素，用<strong>L[0:3]实现，表示从索引0开始取，直到索引3为止，但不包括索引3</strong>。<a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L[<span class="number">0</span>:<span class="number">3</span>]  <span class="comment"># ['Adam', 'Lisa', 'Bart']</span></span><br><span class="line"><span class="comment"># 如果第一个索引是0，可以省略</span></span><br><span class="line">L[:<span class="number">3</span>]  <span class="comment"># ['Adam', 'Lisa', 'Bart']</span></span><br><span class="line"><span class="comment"># 也可以从索引1开始，取出2个元素出来</span></span><br><span class="line">L[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment"># ['Lisa', 'Bart']</span></span><br><span class="line"><span class="comment"># 只用一个“:”，表示从头到尾取出所有元素，L[:]实际上复制出了一个新list</span></span><br><span class="line">L[:]  <span class="comment"># ['Adam', 'Lisa', 'Bart', 'Paul']</span></span><br></pre></td></tr></table></figure><p>切片操作还可以指定第三个参数，<strong>第三个参数表示每N个元素取一个</strong>，上面的L[::2]会每两个元素取出一个来，也就是隔一个取一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L[::<span class="number">2</span>]  <span class="comment"># ['Adam', 'Bart']</span></span><br></pre></td></tr></table></figure><p>把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。</p><h5 id="倒序切片"><a href="#倒序切片" class="headerlink" title="倒序切片"></a>倒序切片</h5><p>对于list，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>, <span class="string">'Paul'</span>]</span><br><span class="line">L[<span class="number">-2</span>:]  <span class="comment"># ['Bart', 'Paul']</span></span><br><span class="line">L[:<span class="number">-2</span>]  <span class="comment"># ['Adam', 'Lisa']</span></span><br><span class="line">L[<span class="number">-3</span>:<span class="number">-1</span>]  <span class="comment"># ['Lisa', 'Bart']</span></span><br><span class="line">L[<span class="number">-4</span>:<span class="number">-1</span>:<span class="number">2</span>]  <span class="comment"># ['Adam', 'Bart']</span></span><br></pre></td></tr></table></figure><p><strong>倒数第一个元素的索引是-1。倒序切片包含起始索引，不包含结束索引</strong>。</p><h5 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h5><p>字符串’xxx’和Unicode字符串u’xxx’（Python3不再需要u）也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'ABCDEFG'</span>[:<span class="number">3</span>]  <span class="comment"># 'ABC'</span></span><br><span class="line"><span class="string">'ABCDEFG'</span>[<span class="number">-3</span>:]  <span class="comment"># 'EFG'</span></span><br><span class="line"><span class="string">'ABCDEFG'</span>[::<span class="number">2</span>]  <span class="comment"># 'ACEG'</span></span><br></pre></td></tr></table></figure><p>在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片操作就可以完成。</p></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;h5 id=&quot;list切片&quot;&gt;&lt;a href=&quot;#list切片&quot; class=&quot;headerlink&quot; title=&quot;list切片&quot;&gt;&lt;/a&gt;list切片&lt;/h5&gt;&lt;p&gt;Python提供了切片（Slice）操作符“&lt;strong&gt;:&lt;/strong&gt;”，简化取指定索引范围的操作。&lt;br&gt;L = [&amp;#39;Adam&amp;#39;, &amp;#39;Lisa&amp;#39;, &amp;#39;Bart&amp;#39;, &amp;#39;Paul&amp;#39;]取前3个元素，用&lt;strong&gt;L[0:3]实现，表示从索引0开始取，直到索引3为止，但不包括索引3&lt;/strong&gt;。&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="软件开发" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="Basis" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Basis/"/>
    
    
      <category term="Python基础" scheme="https://xtlei.github.io/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
      <category term="切片" scheme="https://xtlei.github.io/tags/%E5%88%87%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>Python函数</title>
    <link href="https://xtlei.github.io/2020/03/31/Python%E5%87%BD%E6%95%B0/"/>
    <id>https://xtlei.github.io/2020/03/31/Python%E5%87%BD%E6%95%B0/</id>
    <published>2020-03-31T13:52:28.707Z</published>
    <updated>2020-04-24T13:36:09.302Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><h5 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h5><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py11-1.png" alt=" "><a id="more"></a></p><p>Python内置了很多有用的函数可以直接调用。可以在交互式命令行通过help(abs)查看abs函数的帮助信息。</p><p>调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地指出：abs()有且仅有1个参数，但给出了两个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abs(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: abs() takes exactly one argument (<span class="number">2</span> given)</span><br></pre></td></tr></table></figure><p>如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abs(<span class="string">'a'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: bad operand type <span class="keyword">for</span> abs(): <span class="string">'str'</span></span><br></pre></td></tr></table></figure><h5 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h5><p>在Python中，定义一个函数要使用def语句，依次写出函数名、括号、参数和冒号，然后，在缩进块中编写函数体，函数的返回值用return语句返回。<br>以自定义一个求绝对值的my_abs函数为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure><p>请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。</p><h5 id="函数返回多值"><a href="#函数返回多值" class="headerlink" title="函数返回多值"></a>函数返回多值</h5><p>math包提供了sin()和cos()函数，用import引用它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(x, y, step, angle)</span>:</span></span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    <span class="keyword">return</span> nx, ny</span><br></pre></td></tr></table></figure><p>这样就可以同时获得返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, y = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</span><br><span class="line"><span class="keyword">print</span> x, y</span><br><span class="line"><span class="number">151.961524227</span> <span class="number">70.0</span></span><br></pre></td></tr></table></figure><p>但其实Python函数返回的仍然是单一值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</span><br><span class="line"><span class="keyword">print</span> r</span><br><span class="line">(<span class="number">151.96152422706632</span>, <span class="number">70.0</span>)</span><br></pre></td></tr></table></figure><p>用print打印返回结果，返回值是一个tuple！<br>但是，<strong>在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple</strong>。</p><h5 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h5><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 汉诺塔</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(n, a, b, c)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">print</span> a + <span class="string">'--&gt;'</span> + c</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        move(n<span class="number">-1</span>, a, c, b)</span><br><span class="line">        <span class="keyword">print</span> a + <span class="string">'--&gt;'</span> + c</span><br><span class="line">        move(n<span class="number">-1</span>, b, a, c)</span><br></pre></td></tr></table></figure><p>递归函数的优点是定义简单，逻辑清晰。<strong>理论上，所有的递归函数都可以写成循环的方式</strong>，但循环的逻辑不如递归清晰。<br>使用递归函数需要注意防止栈溢出。<strong>在计算机中，函数调用是通过栈（stack）这种数据结构实现的</strong>，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</p><h5 id="定义默认参数"><a href="#定义默认参数" class="headerlink" title="定义默认参数"></a>定义默认参数</h5><p>Python自带的int()函数，其实就有两个参数，既可以传一个参数，又可以传两个参数。int()函数的第二个参数是转换进制，如果不传，默认是十进制 (base=10)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int(<span class="string">'123'</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line">int(<span class="string">'123'</span>, <span class="number">8</span>)</span><br><span class="line"><span class="number">83</span></span><br></pre></td></tr></table></figure><p>函数的默认参数的作用是简化调用，只需要把必须的参数传进去。但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。<br>定义一个计算x的N次方的函数如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p>假设计算平方的次数最多，就可以把n的默认值设定为2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">print(power(<span class="number">5</span>))  <span class="comment">#25</span></span><br></pre></td></tr></table></figure><p><strong>由于函数的参数按从左到右的顺序匹配，所以默认参数只能定义在必需参数的后面</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OK:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn1</span><span class="params">(a, b=<span class="number">1</span>, c=<span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># Error:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn2</span><span class="params">(a=<span class="number">1</span>, b)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h5 id="定义可变参数"><a href="#定义可变参数" class="headerlink" title="定义可变参数"></a>定义可变参数</h5><p>如果想让一个函数能接受任意个参数，可以定义一个可变参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> args</span><br></pre></td></tr></table></figure><p>可变参数的名字前面有个*号，可以传入0个、1个或多个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn()  <span class="comment">#()</span></span><br><span class="line">fn(<span class="string">'a'</span>)  <span class="comment">#('a',)</span></span><br><span class="line">fn(<span class="string">'a'</span>, <span class="string">'b'</span>)  <span class="comment">#('a', 'b')</span></span><br><span class="line">fn(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)  <span class="comment">#('a', 'b', 'c')</span></span><br></pre></td></tr></table></figure><p><strong>Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量args看成一个tuple就好了</strong>。定义可变参数的目的也是为了简化调用。</p></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;h5 id=&quot;函数调用&quot;&gt;&lt;a href=&quot;#函数调用&quot; class=&quot;headerlink&quot; title=&quot;函数调用&quot;&gt;&lt;/a&gt;函数调用&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py11-1.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="软件开发" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="Basis" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Basis/"/>
    
    
      <category term="Python基础" scheme="https://xtlei.github.io/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://xtlei.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python中set类型</title>
    <link href="https://xtlei.github.io/2020/03/31/Python%E4%B8%ADset%E7%B1%BB%E5%9E%8B/"/>
    <id>https://xtlei.github.io/2020/03/31/Python%E4%B8%ADset%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-03-31T13:35:18.581Z</published>
    <updated>2020-04-24T09:50:31.210Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><p>set像list一样，有一系列元素，但是<strong>set的元素没有重复，而且是无序的</strong>，这和dict的key很像。</p><a id="more"></a><h5 id="set的特点"><a href="#set的特点" class="headerlink" title="set的特点"></a>set的特点</h5><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py10-1.png" alt=" "></p><p>set的内部结构和dict很像，唯一区别是<strong>不存储value</strong>，因此，判断一个元素是否在set中速度很快。<br><strong>set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的</strong>。<br><strong>set存储的元素也是没有顺序的</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">weekdays = set([<span class="string">'MON'</span>, <span class="string">'TUE'</span>, <span class="string">'WED'</span>, <span class="string">'THU'</span>, <span class="string">'FRI'</span>, <span class="string">'SAT'</span>, <span class="string">'SUN'</span>])</span><br><span class="line">x = input() <span class="comment"># 用户输入的字符串</span></span><br><span class="line"><span class="keyword">if</span> x <span class="keyword">in</span> weekdays:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'input ok'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'input error'</span></span><br></pre></td></tr></table></figure><h5 id="set的处理方法"><a href="#set的处理方法" class="headerlink" title="set的处理方法"></a>set的处理方法</h5><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py10-2.png" alt=" "></p><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py10-3.png" alt=" "></p><h5 id="创建set"><a href="#创建set" class="headerlink" title="创建set"></a>创建set</h5><p>可以直接通过<strong>{}</strong>创建set，亦可以调用set()函数（可以理解为强制类型转换）创建。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="string">'123'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>&#125;</span><br><span class="line">print(set1)  <span class="comment"># &#123;'123','1','2'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入一个list，list的元素将作为set的元素：</span></span><br><span class="line">s = set([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>])</span><br><span class="line">print(s)  <span class="comment"># &#123;'A', 'C', 'B'&#125;</span></span><br><span class="line"></span><br><span class="line">s = set(<span class="string">'12345'</span>)</span><br><span class="line">print(s)  <span class="comment"># &#123;'1','2','3','4','5'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入包含重复元素的list,set会自动去掉重复元素</span></span><br><span class="line"><span class="comment"># 如下，原来的list有4个元素，但set只有3个元素</span></span><br><span class="line">s = set([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'C'</span>])</span><br><span class="line">print(s)  <span class="comment"># &#123;'A', 'C', 'B'&#125;</span></span><br><span class="line">len(s)  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h5 id="访问set"><a href="#访问set" class="headerlink" title="访问set"></a>访问set</h5><p>访问set中的某个元素实际上就是判断一个元素是否在set中。由于set也是一个集合，所以，遍历set和遍历list类似，都可以通过for循环实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>, <span class="string">'Paul'</span>])</span><br><span class="line">print(<span class="string">'bart'</span> <span class="keyword">in</span> s)  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">s = set([<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>])</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> s:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure><h5 id="更新set"><a href="#更新set" class="headerlink" title="更新set"></a>更新set</h5><p>由于set存储的是一组不重复的无序元素，因此，更新set操作主要是添加新元素到set中和删除set已有元素两种。<br>添加元素时，用set的add()方法。如果添加的元素已经存在，add()不会报错，但是不再添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line">print(s)  <span class="comment"># &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line">s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">s.add(<span class="number">3</span>)</span><br><span class="line">print(s)  <span class="comment"># &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure><p>删除元素时，用set的remove()方法。如果删除的元素不存在set中，remove()会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">s.remove(<span class="number">4</span>)</span><br><span class="line">print(s)  <span class="comment"># &#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line">s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">s.remove(<span class="number">4</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">      File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>所以<strong>用add()可以直接添加，而使用remove()前需要判断</strong>。</p><h5 id="set操作符"><a href="#set操作符" class="headerlink" title="set操作符"></a>set操作符</h5><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py10-4.png" alt=" "></p><p>另有&lt;=，&lt;，&gt;=，&gt;两组关系操作符判断集合的包含关系。<br><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py10-5.png" alt=" "></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A = &#123;<span class="string">'p'</span>, <span class="string">'y'</span>, <span class="string">'123'</span>&#125;</span><br><span class="line">B = set(<span class="string">'pypy123'</span>)  <span class="comment">#B = &#123;'p', 'y', '1', '2', '3'&#125;</span></span><br><span class="line"></span><br><span class="line">A |= B</span><br><span class="line">print(A)  <span class="comment"># &#123;'p','y','123','1','2','3'&#125;</span></span><br><span class="line"></span><br><span class="line">A -= B</span><br><span class="line">print(A)  <span class="comment"># &#123;'123'&#125;</span></span><br><span class="line"></span><br><span class="line">A &amp;= B</span><br><span class="line">print(A)  <span class="comment"># &#123;'p','y'&#125;</span></span><br><span class="line"></span><br><span class="line">A ^= B</span><br><span class="line">print(A)  <span class="comment"># &#123;'123','1','2','3'&#125;</span></span><br></pre></td></tr></table></figure><h5 id="set应用"><a href="#set应用" class="headerlink" title="set应用"></a>set应用</h5><p>1.关系比较（判断包含关系）<br>2.数据去重</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">s = set(l)</span><br><span class="line">l = list(s)</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;p&gt;set像list一样，有一系列元素，但是&lt;strong&gt;set的元素没有重复，而且是无序的&lt;/strong&gt;，这和dict的key很像。&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="软件开发" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="Basis" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Basis/"/>
    
    
      <category term="Python基础" scheme="https://xtlei.github.io/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
      <category term="set" scheme="https://xtlei.github.io/tags/set/"/>
    
      <category term="集合" scheme="https://xtlei.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Python中dict类型</title>
    <link href="https://xtlei.github.io/2020/03/31/Python%E4%B8%ADdict%E7%B1%BB%E5%9E%8B/"/>
    <id>https://xtlei.github.io/2020/03/31/Python%E4%B8%ADdict%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-03-31T13:15:20.091Z</published>
    <updated>2020-04-24T09:29:46.794Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py9-1.png" alt=" "><a id="more"></a></p><p>Python中list和tuple可以用来表示顺序集合，例如，班里同学的名字：[‘Adam’, ‘Lisa’, ‘Bart’]或者考试的成绩列表：[95, 85, 59]。<br>Python用dict表示“名字”-“成绩”的查找表如下，<strong>花括号{}表示这是一个dict，然后按照key: value,写出来即可</strong>。最后一个key: value的逗号可以省略。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    <span class="string">'Adam'</span>: <span class="number">95</span>,</span><br><span class="line">    <span class="string">'Lisa'</span>: <span class="number">85</span>,</span><br><span class="line">    <span class="string">'Bart'</span>: <span class="number">59</span></span><br><span class="line">&#125;</span><br><span class="line">print(len(d)) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增键值对 Cindy:65</span></span><br><span class="line">d[<span class="string">'Cindy'</span>] = <span class="number">65</span></span><br></pre></td></tr></table></figure><h5 id="dict访问"><a href="#dict访问" class="headerlink" title="dict访问"></a>dict访问</h5><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py9-2.png" alt=" "></p><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py9-3.png" alt=" "></p><p>对于以上Dict，使用d[key]的形式来查找对应的value，这和list很像，不同之处是，<strong>list必须使用索引返回对应的元素，而dict使用key</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (d[<span class="string">'Adam'</span>]) <span class="comment"># 95</span></span><br><span class="line"><span class="keyword">print</span> (d[<span class="string">'Paul'</span>])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"index.py"</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">print</span> d[<span class="string">'Paul'</span>]</span><br><span class="line">KeyError: <span class="string">'Paul'</span></span><br></pre></td></tr></table></figure><p>注意:通过key访问dict的value，只要key存在，dict就返回对应的value。如果key不存在，会直接报错：KeyError。要避免KeyError发生，有两个办法：<br>一是先判断一下key是否存在，如果&#39;Paul&#39;不存在，if语句判断为False，自然不会执行print d[&#39;Paul&#39;]，从而避免了错误。用in操作符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">'Paul'</span> <span class="keyword">in</span> d:</span><br><span class="line">    <span class="keyword">print</span> (d[<span class="string">'Paul'</span>])</span><br></pre></td></tr></table></figure><p>二是使用dict本身提供的一个get方法，在key不存在的时候，返回None：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (d.get(<span class="string">'Bart'</span>)) <span class="comment"># 59</span></span><br><span class="line"><span class="keyword">print</span> (d.get(<span class="string">'Paul'</span>)) <span class="comment"># None</span></span><br></pre></td></tr></table></figure><h5 id="dict特点"><a href="#dict特点" class="headerlink" title="dict特点"></a>dict特点</h5><p>dict的第一个特点是<strong>查找速度快</strong>，无论dict有10个元素还是10万个元素，查找速度都一样。而list的查找速度随着元素增加而逐渐下降。不过dict的查找速度快不是没有代价的，<strong>dict的缺点是占用内存大，还会浪费很多内容，list正好相反，占用内存小，但是查找速度慢</strong>。<br>由于dict是按key查找，所以，<strong>在一个dict中，key不能重复</strong>。</p><p>dict的第二个特点就是<strong>存储的key-value序对是没有顺序的</strong>！而list是有序的，当打印以上dict时，打印的顺序不一定是创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明dict内部是无序的，不能用dict存储有序的集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (d) <span class="comment"># &#123;'Lisa': 85, 'Adam': 95, 'Bart': 59&#125;</span></span><br></pre></td></tr></table></figure><p>dict的第三个特点是<strong>作为key的元素必须不可变，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为key。但是list是可变的，就不能作为key</strong>。<br><strong>不可变这个限制仅作用于key，value是否可变无所谓</strong>。</p><h5 id="更新dict"><a href="#更新dict" class="headerlink" title="更新dict"></a>更新dict</h5><p>dict是可变的，可以随时往dict中添加新的key-value。如果key已经存在，则赋值会用新的value替换掉原来的value：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d[<span class="string">'Paul'</span>] = <span class="number">72</span></span><br><span class="line"><span class="keyword">print</span> (d) <span class="comment"># &#123;'Lisa': 85, 'Paul': 72, 'Adam': 95, 'Bart': 59&#125;</span></span><br><span class="line"></span><br><span class="line">d[<span class="string">'Bart'</span>] = <span class="number">60</span></span><br><span class="line">print(d) <span class="comment"># &#123;'Lisa': 85, 'Paul': 72, 'Adam': 95, 'Bart': 60&#125;</span></span><br></pre></td></tr></table></figure><h5 id="遍历dict"><a href="#遍历dict" class="headerlink" title="遍历dict"></a>遍历dict</h5><p>由于dict也是一个集合，所以，遍历dict和遍历list类似，都可以通过for循环实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用for循环可以遍历dict的key：</span></span><br><span class="line">d = &#123; <span class="string">'Adam'</span>: <span class="number">95</span>, <span class="string">'Lisa'</span>: <span class="number">85</span>, <span class="string">'Bart'</span>: <span class="number">59</span> &#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">    print(key)</span><br><span class="line">Lisa</span><br><span class="line">Adam</span><br><span class="line">Bart</span><br></pre></td></tr></table></figure><p>由于通过key可以获取对应的value，因此，在循环体内，可以获取到value的值。<br><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py9-4.png" alt=" "></p></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;p&gt;&lt;img src=&quot;https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py9-1.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="软件开发" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="Basis" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Basis/"/>
    
    
      <category term="Python基础" scheme="https://xtlei.github.io/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
      <category term="字典" scheme="https://xtlei.github.io/tags/%E5%AD%97%E5%85%B8/"/>
    
      <category term="dict" scheme="https://xtlei.github.io/tags/dict/"/>
    
  </entry>
  
  <entry>
    <title>Python语句</title>
    <link href="https://xtlei.github.io/2020/03/31/Python%E8%AF%AD%E5%8F%A5/"/>
    <id>https://xtlei.github.io/2020/03/31/Python%E8%AF%AD%E5%8F%A5/</id>
    <published>2020-03-31T07:44:16.401Z</published>
    <updated>2020-04-24T09:18:05.155Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><h4 id="Python判断语句"><a href="#Python判断语句" class="headerlink" title="Python判断语句"></a>Python判断语句</h4><h5 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h5><p>比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，可以用if语句实现：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'your age is'</span>, age</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'adult'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'END'</span></span><br></pre></td></tr></table></figure><p><strong>注意:Python代码的缩进规则：具有相同缩进的代码被视为代码块</strong>。<br>上面的3，4行print语句就构成一个代码块（但不包括第5行的print）。如果if语句判断为True，就会执行这个代码块。另外，<strong>缩进要严格按照Python的习惯写法：4个空格</strong>，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。<br><strong>if语句后接表达式，然后用“:”表示代码块开始</strong>。</p><h5 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'adult'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'teenager'</span></span><br></pre></td></tr></table></figure><p>“非此即彼”情况下，利用if … else …语句，可以根据条件表达式的值为True或者False，分别执行if代码块或者else代码块。<br>注意:else后面有个“:”。</p><h5 id="if-elif-else语句"><a href="#if-elif-else语句" class="headerlink" title="if-elif-else语句"></a>if-elif-else语句</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'adult'</span></span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'teenager'</span></span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'kid'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'baby'</span></span><br></pre></td></tr></table></figure><p>其中，elif意思就是else if。<br><strong>特别注意:这一系列条件判断会从上到下依次判断，如果某个判断为True，执行完对应的代码块，后面的条件判断就直接忽略，不再执行了</strong>。</p><h4 id="Python循环语句"><a href="#Python循环语句" class="headerlink" title="Python循环语句"></a>Python循环语句</h4><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>Python的for循环就可以依次把list或tuple的每个元素迭代出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> L:</span><br><span class="line">    <span class="keyword">print</span> name</span><br></pre></td></tr></table></figure><p>注意:name这个变量是在for循环中定义的，意思是，依次取出list中的每一个元素，并把元素赋值给name，然后执行for循环体（就是缩进的代码块）。</p><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p>while循环不会迭代list或tuple的元素，而是根据表达式判断循环是否结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从0开始打印不大于N的整数：</span></span><br><span class="line">N = <span class="number">10</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> x &lt; N:</span><br><span class="line">    <span class="keyword">print</span> x</span><br><span class="line">    x = x + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>while循环每次先判断 x &lt; N，如果为True，则执行循环体的代码块，否则，退出循环。<br>在循环体内，x = x + 1会让x不断增加，最终因为x &lt; N不成立而退出循环。<br>如果没有这一个语句，while循环在判断x &lt; N时总是为True，就会无限循环下去，变成死循环，所以要特别留意while循环的退出条件。</p><h5 id="break退出循环"><a href="#break退出循环" class="headerlink" title="break退出循环"></a>break退出循环</h5><p>用for循环或者while循环时，如果要在循环体内直接退出循环，可以使用break语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算1至100的整数和</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sum = sum + x</span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">print</span> sum</span><br></pre></td></tr></table></figure><p>在循环体内判断x &gt; 100条件成立时，用break语句退出循环，这样避免死循环，实现循环的结束。</p><h5 id="continue继续循环"><a href="#continue继续循环" class="headerlink" title="continue继续循环"></a>continue继续循环</h5><p>在循环过程中，用continue跳过本次后续的循环代码，继续下一次循环。<br>假设利用for循环计算平均分的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">75</span>, <span class="number">98</span>, <span class="number">59</span>, <span class="number">81</span>, <span class="number">66</span>, <span class="number">43</span>, <span class="number">69</span>, <span class="number">85</span>]</span><br><span class="line">sum = <span class="number">0.0</span></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> L:</span><br><span class="line">    sum = sum + x</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> sum / n</span><br></pre></td></tr></table></figure><p>现在只想统计及格分数的平均分，就要把x &lt; 60的分数剔除掉，这时，利用 continue，可以做到当x &lt; 60的时候，不继续执行循环体的后续代码，直接进入下一次循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> L:</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">60</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    sum = sum + x</span><br><span class="line">    n = n + <span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="循环与else"><a href="#循环与else" class="headerlink" title="循环与else"></a>循环与else</h5><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py8-1.png" alt=" "></p><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py8-2.png" alt=" "></p></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;h4 id=&quot;Python判断语句&quot;&gt;&lt;a href=&quot;#Python判断语句&quot; class=&quot;headerlink&quot; title=&quot;Python判断语句&quot;&gt;&lt;/a&gt;Python判断语句&lt;/h4&gt;&lt;h5 id=&quot;if语句&quot;&gt;&lt;a href=&quot;#if语句&quot; class=&quot;headerlink&quot; title=&quot;if语句&quot;&gt;&lt;/a&gt;if语句&lt;/h5&gt;&lt;p&gt;比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，可以用if语句实现：&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="软件开发" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="Basis" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Basis/"/>
    
    
      <category term="Python基础" scheme="https://xtlei.github.io/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
      <category term="语句" scheme="https://xtlei.github.io/tags/%E8%AF%AD%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>Python中tuple类型</title>
    <link href="https://xtlei.github.io/2020/03/31/Python%E4%B8%ADtuple%E7%B1%BB%E5%9E%8B/"/>
    <id>https://xtlei.github.io/2020/03/31/Python%E4%B8%ADtuple%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-03-31T07:05:21.151Z</published>
    <updated>2020-04-24T09:07:23.745Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py7-1.png" alt=" "></p><a id="more"></a><h5 id="创建tuple"><a href="#创建tuple" class="headerlink" title="创建tuple"></a>创建tuple</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>) <span class="comment">#使用()创建</span></span><br><span class="line">t = tuple((<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>))</span><br><span class="line">t = <span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>  <span class="comment"># 'A', 'B' 不论是否用小括号包括，本身就是元组类型</span></span><br></pre></td></tr></table></figure><p><strong>创建tuple和创建list唯一不同之处是用( )替代了[ ]</strong>。<br><strong>创建后元组t就不能改变了，不能向tuple中删除和添加元素</strong>。</p><p>获取tuple元素的方式和list是一样的，可以使用t[0]，t[-1]等索引方式访问元素，但是不能赋值成别的元素，否则就会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t[<span class="number">0</span>] = <span class="string">'Paul'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure><p>tuple和list一样，可以包含0个、1个和任意多个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含0个元素的tuple，也就是空tuple</span></span><br><span class="line">t = ()</span><br><span class="line">print(t)  <span class="comment"># ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#包含一个元素的tuple</span></span><br><span class="line">t = (<span class="number">1</span>)</span><br><span class="line">print(t)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>上述包含一个元素1的元组输出内容为整数1，不是元组类型(1)。因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果(1)被Python解释器计算出结果1，导致我们得到的不是tuple，而是整数1。<br>正是因为用()定义单元素的tuple有歧义，所以<strong>Python规定，单元素tuple要多加一个逗号“,”</strong>，这样就避免了歧义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>,)</span><br><span class="line">print(t)  <span class="comment"># (1,)</span></span><br><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,)</span><br><span class="line">print(t)  <span class="comment"># (1, 2, 3)</span></span><br></pre></td></tr></table></figure><p>Python在打印单元素tuple时，也自动添加了一个“,”，为了更明确地表明这是一个tuple。多元素tuple加不加这个额外的“,”效果是一样的。</p><h5 id="“可变”的tuple"><a href="#“可变”的tuple" class="headerlink" title="“可变”的tuple"></a>“可变”的tuple</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'A'</span>, <span class="string">'B'</span>])</span><br><span class="line">L = t[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>注意到t有3个元素：&#39;a&#39;，&#39;b&#39;和一个list：[&#39;A&#39;, &#39;B&#39;]。list作为一个整体是tuple的第3个元素，可以通过t[2]拿到。<br>修改list的两个元素，再看tuple的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L[<span class="number">0</span>] = <span class="string">'X'</span></span><br><span class="line">L[<span class="number">1</span>] = <span class="string">'Y'</span></span><br><span class="line">print(t)  <span class="comment"># ('a', 'b', ['X', 'Y'])</span></span><br></pre></td></tr></table></figure><p>不是说tuple一旦定义后就不可变了吗？怎么现在又变了？<br>定义的时候tuple包含的3个元素：<br><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py7-2.png" alt=" "></p><p>当把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为：<br><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py7-3.png" alt=" "></p><p>表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向&#39;a&#39;，就不能改成指向&#39;b&#39;，指向一个list，就不能改成指向其他对象，但这里指向的list本身可变导致tuple“可变”。所以要创建一个内容不变的tuple必须保证tuple的每一个元素本身也不能变。</p></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;p&gt;&lt;img src=&quot;https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py7-1.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="软件开发" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="Basis" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Basis/"/>
    
    
      <category term="Python基础" scheme="https://xtlei.github.io/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
      <category term="序列" scheme="https://xtlei.github.io/tags/%E5%BA%8F%E5%88%97/"/>
    
      <category term="tuple" scheme="https://xtlei.github.io/tags/tuple/"/>
    
      <category term="元组" scheme="https://xtlei.github.io/tags/%E5%85%83%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Python中list类型</title>
    <link href="https://xtlei.github.io/2020/03/31/Python%E4%B8%ADlist%E7%B1%BB%E5%9E%8B/"/>
    <id>https://xtlei.github.io/2020/03/31/Python%E4%B8%ADlist%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-03-31T03:03:57.337Z</published>
    <updated>2020-04-24T08:47:52.812Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py6-1.png" alt=" "> <a id="more"></a></p><p><strong>list是一种有序的集合，其中的元素是按照顺序排列的，可以随时添加和删除其中的元素</strong>。<br>构造list非常简单，直接用<strong>[]</strong>把list的所有元素都括起来，就是一个list对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用list列出班里所有同学的名字</span></span><br><span class="line">classmates = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]   </span><br><span class="line"><span class="comment">#等价于 classmates = list(['Michael', 'Bob', 'Tracy'])</span></span><br><span class="line">print(classmates)<span class="comment"># ['Michael', 'Bob', 'Tracy']</span></span><br></pre></td></tr></table></figure><p>由于Python是动态语言，所以list中包含的元素并不要求都必须是同一种数据类型，完全可以在list中包含各种数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">'Michael'</span>, <span class="number">100</span>, <span class="literal">True</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个元素也没有的list，即空list</span></span><br><span class="line">empty_list = []</span><br></pre></td></tr></table></figure><h5 id="Python按照索引访问list"><a href="#Python按照索引访问list" class="headerlink" title="Python按照索引访问list"></a>Python按照索引访问list</h5><p>通过索引来获取list中的指定元素。索引从0开始，也就是说，第一个元素的索引是0，第二个元素的索引是1，以此类推。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>]</span><br><span class="line"><span class="keyword">print</span> L[<span class="number">0</span>] <span class="comment"># 要打印第一名同学的名字</span></span><br><span class="line"><span class="keyword">print</span> L[<span class="number">3</span>] <span class="comment"># 打印第四名同学的名字</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure><p>IndexError表示索引超出了范围，因为上面的list只有3个元素，有效的索引是0，1，2。所以，使用索引时，不论正数还是负数索引，注意不要越界。</p><h5 id="list常用方法"><a href="#list常用方法" class="headerlink" title="list常用方法"></a>list常用方法</h5><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py6-2.png" alt=" "></p><p>L.insert(0, &#39;Paul&#39;)的作用是将&#39;Paul&#39;添加到索引为0的位置上（也就是第一个），而原来索引为0的Adam同学，以及后面的所有同学，都自动向后移动一位。<br>pop()方法可以不接受参数直接删掉list的最后一个元素，也可以接受索引号作为参数，删除索引位置上的元素，同时都会返回删除的元素。<br>另外，序列中del()，index()，max()，min()，len()等函数分别用于列表的元素删除，查看元素下标，最大值，最小值，如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>, <span class="string">'Bob'</span>, <span class="string">'Tian'</span>]</span><br><span class="line">L.insert(<span class="number">0</span>, <span class="string">'Paul'</span>)</span><br><span class="line">L.pop(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改第一个元素的值为'Da'</span></span><br><span class="line">L[<span class="number">0</span>] = <span class="string">'Da'</span></span><br><span class="line"><span class="comment"># 删除下标为1的元素</span></span><br><span class="line"><span class="keyword">del</span> L[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 删除第1-3位置的元素</span></span><br><span class="line"><span class="keyword">del</span> L[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"><span class="comment"># 'Bob'在列表中的索引</span></span><br><span class="line">L.index(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="comment"># 列表长度</span></span><br><span class="line">len(L)</span><br><span class="line"><span class="comment"># 列表最大值</span></span><br><span class="line">max(L)</span><br></pre></td></tr></table></figure></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;p&gt;&lt;img src=&quot;https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py6-1.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="软件开发" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="Basis" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Basis/"/>
    
    
      <category term="Python基础" scheme="https://xtlei.github.io/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
      <category term="list" scheme="https://xtlei.github.io/tags/list/"/>
    
      <category term="列表" scheme="https://xtlei.github.io/tags/%E5%88%97%E8%A1%A8/"/>
    
      <category term="序列" scheme="https://xtlei.github.io/tags/%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python字符串</title>
    <link href="https://xtlei.github.io/2020/03/31/Python%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://xtlei.github.io/2020/03/31/Python%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-03-31T02:57:17.008Z</published>
    <updated>2020-04-24T06:08:47.068Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><h4 id="一、字符串"><a href="#一、字符串" class="headerlink" title="一、字符串"></a>一、字符串</h4><p>Python中字符串类型和list类型及tuple类型都是有序列表的一种扩展形式。主要特征是可以通过序列的下标访问其中的元素。<a id="more"></a></p><p>Python字符串是使用单个到三个引号括起来的任意文本。<br>如果字符串本身包含单引号，比如表示字符串I&#39;m OK，这时，可以用双引号表示：&quot;I&#39;m OK&quot;。类似的，如果字符串包含双引号，就可以用单引号括起来表示：&#39;Learn &quot;Python&quot; in imooc&#39;。<br>如果字符串既包含单引号又包含双引号，需要对字符串的某些特殊字符进行“转义”，Python字符串用\进行转义。比如，要表示字符串Bob said &quot;I&#39;m OK&quot;.。在需要转义的引号前面插入一个\表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为&#39;Bob said \&quot;I\&#39;m OK\&quot;.&#39;。<br>常用的转义字符还有：\n(表示换行)、\t(表示一个制表符)、\\(表示\字符本身)<br><strong>注意：转义字符\不计入字符串的内容中。</strong></p><h5 id="raw字符串和多行字符串"><a href="#raw字符串和多行字符串" class="headerlink" title="raw字符串和多行字符串"></a>raw字符串和多行字符串</h5><p>如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，可以在字符串前面加个前缀r，表示这是一个raw字符串，里面的字符就不需要转义了。例如：r&#39;/*/*/&#39;。但是r&#39;…&#39;表示法不能表示多行字符串，也不能表示包含&#39;和&quot;的字符串。</p><p>如果要表示多行字符串，可以用&#39;&#39;&#39;…&#39;&#39;&#39;表示（<strong>三引号字符串赋值给变量即为字符串，否则就作为注释</strong>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''Line 1</span></span><br><span class="line"><span class="string">Line 2</span></span><br><span class="line"><span class="string">Line 3'''</span></span><br></pre></td></tr></table></figure><p>上面这个字符串的表示方法和下面的是完全一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Line 1\nLine 2\nLine 3'</span></span><br></pre></td></tr></table></figure><p>还可以在多行字符串前面添加r，把这个多行字符串也变成一个raw字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">r'''Python is created by "Guido".</span></span><br><span class="line"><span class="string">It is free and easy to learn.</span></span><br><span class="line"><span class="string">Let's start learn Python in imooc!'''</span></span><br></pre></td></tr></table></figure><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py5-1.png" alt=" "></p><h4 id="二、Unicode字符串"><a href="#二、Unicode字符串" class="headerlink" title="二、Unicode字符串"></a>二、Unicode字符串</h4><p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），0 - 255被用来表示大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。<br>如果要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。<br>Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。<br>因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码，普通的字符&#39;ABC&#39;在Python内部都是ASCII编码的。</p><p>Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u&#39;…&#39;表示，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">u'中文'</span>)</span><br></pre></td></tr></table></figure><p><strong>注意:Python2不加u，中文就不能正常显示。Python3不用加u。</strong><br>Unicode字符串除了多了一个u之外，与普通字符串没啥区别，转义字符和多行表示法仍然有效：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#转义：</span></span><br><span class="line"><span class="string">u'中文\n日文\n韩文'</span></span><br><span class="line"><span class="comment">#多行：</span></span><br><span class="line"><span class="string">u'''第一行</span></span><br><span class="line"><span class="string">   第二行'''</span></span><br><span class="line"><span class="comment">#raw+多行：</span></span><br><span class="line"><span class="string">ur'''Python的Unicode字符串支持"中文",</span></span><br><span class="line"><span class="string">   "日文",</span></span><br><span class="line"><span class="string">   "韩文"等多种语言'''</span></span><br></pre></td></tr></table></figure><p><strong>如果中文字符串在Python环境下遇到UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加如下注释，让Python解释器，用UTF-8编码读取源代码。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;h4 id=&quot;一、字符串&quot;&gt;&lt;a href=&quot;#一、字符串&quot; class=&quot;headerlink&quot; title=&quot;一、字符串&quot;&gt;&lt;/a&gt;一、字符串&lt;/h4&gt;&lt;p&gt;Python中字符串类型和list类型及tuple类型都是有序列表的一种扩展形式。主要特征是可以通过序列的下标访问其中的元素。&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="软件开发" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="Basis" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Basis/"/>
    
    
      <category term="Python基础" scheme="https://xtlei.github.io/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
      <category term="字符串" scheme="https://xtlei.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Unicode" scheme="https://xtlei.github.io/tags/Unicode/"/>
    
  </entry>
  
  <entry>
    <title>Python的print语句</title>
    <link href="https://xtlei.github.io/2020/03/31/Python%E7%9A%84print%E8%AF%AD%E5%8F%A5/"/>
    <id>https://xtlei.github.io/2020/03/31/Python%E7%9A%84print%E8%AF%AD%E5%8F%A5/</id>
    <published>2020-03-31T02:16:58.243Z</published>
    <updated>2020-04-24T05:53:38.926Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><p>print语句可以向屏幕上输出指定的文字。在Python2和Python3中都提供print()方法来打印信息,但两个版本间的print稍微有差异。<a id="more"></a></p><p><strong>Python3中print是一个内置函数，有多个参数，所以打印时必须要加括号</strong>：print(&quot;hello world&quot;)；Python2中print是一个语法结构，打印时可以不加括号：print &#39;hello world&#39;。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(value1, ..., sep=<span class="string">' '</span>, end=<span class="string">'\n'</span>, file=sys.stdout, flush=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>从上面的Python3方法原型可以看出，<br>①. print可以支持多个参数，支持同时打印多个字符串（其中…表示任意多个字符串）；<br>②. sep表示多个字符串之间使用什么字符连接；<br>③. end表示字符串结尾添加什么字符，指点该参数就可以设置打印不换行，Python2.x下的print语句在输出字符串之后会默认换行，如果不希望换行，只要在语句最后加一个“,”即可。但是在Python 3.x下，print()变成内置函数，加“,”的老方法就行不通了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"python"</span>, <span class="string">"tab"</span>, <span class="string">".com"</span>, sep=<span class="string">''</span>, end=<span class="string">''</span>) <span class="comment">#就可以实现打印出来不换行</span></span><br><span class="line">pythontab.com</span><br></pre></td></tr></table></figure><p><strong>Python2加括号，解释器可能会把它当成创建tuple</strong>，比如:print (&#39;hhh&#39;,&#39;ggg&#39;)，对于这个，Python2打印的是(&#39;hhh&#39;,&#39;ggg&#39;)，而Python3打印的是hhh ggg。除非括号里只有一个字符串，比如，print (&#39;hhh&#39;)在Python2和Python3中都是打印hhh，毕竟(&#39;hhh&#39;)==&#39;hhh&#39;，所以Python2才会视它为字符串而不是元组。</p></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;p&gt;print语句可以向屏幕上输出指定的文字。在Python2和Python3中都提供print()方法来打印信息,但两个版本间的print稍微有差异。&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="软件开发" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="Basis" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Basis/"/>
    
    
      <category term="Python基础" scheme="https://xtlei.github.io/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
      <category term="print" scheme="https://xtlei.github.io/tags/print/"/>
    
  </entry>
  
  <entry>
    <title>Python变量</title>
    <link href="https://xtlei.github.io/2020/03/31/Python%E5%8F%98%E9%87%8F/"/>
    <id>https://xtlei.github.io/2020/03/31/Python%E5%8F%98%E9%87%8F/</id>
    <published>2020-03-31T02:06:31.011Z</published>
    <updated>2020-04-24T05:55:59.399Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><p>在Python程序中，变量是用一个变量名表示，变量名必须是大小写英文、数字和下划线（_）的组合，且不能用数字开头。<a id="more"></a><br><strong>在Python中，等号=连接的是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量</strong>，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123</span>    </span><br><span class="line">print(a)<span class="comment"># a是整数</span></span><br><span class="line">a = <span class="string">'imooc'</span>   </span><br><span class="line">print(a)<span class="comment"># a变为字符串</span></span><br></pre></td></tr></table></figure><p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。<br>静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>; <span class="comment">// a是整数类型变量</span></span><br><span class="line">a = <span class="string">"mooc"</span>; <span class="comment">// 错误：不能把字符串赋给整型变量</span></span><br></pre></td></tr></table></figure><p>不要把赋值语句的等号等同于数学的等号。比如下面的代码，如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">x = x + <span class="number">2</span></span><br></pre></td></tr></table></figure><p>最后，理解变量在计算机内存中的表示也非常重要。当编写代码：a = &#39;ABC&#39;时，Python解释器干了两件事情：<br><strong>1. 在内存中创建了一个&#39;ABC&#39;的字符串；<br>2. 在内存中创建了一个名为a的变量，并把它指向&#39;ABC&#39;。</strong></p><p>也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'ABC'</span></span><br><span class="line">b = a</span><br><span class="line">a = <span class="string">'XYZ'</span></span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>最后一行打印出变量b的内容到底是&#39;ABC&#39;呢还是&#39;XYZ&#39;？如果从数学意义上理解，就会错误地得出b和a相同，也应该是&#39;XYZ&#39;，但实际上b的值是&#39;ABC&#39;，下面逐行执行代码查看每行的效果：<br>执行a = &#39;ABC&#39;，解释器创建了字符串&#39;ABC&#39;和变量a，并把a指向&#39;ABC&#39;：<br><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py4-1.png" alt=" "></p><p>执行b = a，解释器创建了变量b，并<strong>把b指向a指向的字符串&#39;ABC&#39;</strong>：<br><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py4-2.png" alt=" "></p><p>执行a = &#39;XYZ&#39;，解释器创建了字符串&#39;XYZ&#39;，并把a的指向改为&#39;XYZ&#39;，但b并没有更改：<br><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py4-3.png" alt=" "></p><p>所以，最后打印变量b的结果自然是&#39;ABC&#39;了。<br><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/py4-4.png" alt=" "></p></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;p&gt;在Python程序中，变量是用一个变量名表示，变量名必须是大小写英文、数字和下划线（_）的组合，且不能用数字开头。&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="软件开发" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="Basis" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Basis/"/>
    
    
      <category term="Python基础" scheme="https://xtlei.github.io/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
      <category term="变量" scheme="https://xtlei.github.io/tags/%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python数据类型</title>
    <link href="https://xtlei.github.io/2020/03/15/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://xtlei.github.io/2020/03/15/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-03-15T13:56:22.185Z</published>
    <updated>2020-04-24T05:58:32.039Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><h4 id="一、整数"><a href="#一、整数" class="headerlink" title="一、整数"></a>一、整数</h4><p>Python可以处理任意大小的整数，当然包括负整数，在Python程序中，整数的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。</p><a id="more"></a><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/python1.png" alt=" "></p><h4 id="二、浮点数"><a href="#二、浮点数" class="headerlink" title="二、浮点数"></a>二、浮点数</h4><p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9和12.3x10^8是相等的。浮点数可以用数学写法，如1.23，3.14，-9.01等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p><p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的，而浮点数运算则可能会有四舍五入的误差。<strong>浮点数运算存在不确定尾数</strong>，运算的结果不一定精确。因为计算机内存再大，也无法精确表示出无限循环小数，比如 0.1 换成二进制表示就是无限循环小数。<br><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/python2.png" alt=" "></p><p><strong>Python的整数运算结果仍然是整数，浮点数运算结果仍然是浮点数，但是整数和浮点数混合运算的结果就变成浮点数了</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">1</span> + <span class="number">2</span>)    <span class="comment"># ==&gt; 整数 3 </span></span><br><span class="line">print(<span class="number">1.0</span> + <span class="number">2.0</span>)    <span class="comment"># ==&gt; 浮点数 3.0 </span></span><br><span class="line">print(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>)    <span class="comment"># ==&gt; False </span></span><br><span class="line">print(round(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">1</span>) == <span class="number">0.3</span>)     <span class="comment"># ==&gt; True</span></span><br><span class="line">print(<span class="number">1</span> + <span class="number">2.0</span>)    <span class="comment"># ==&gt; 浮点数 3.0</span></span><br></pre></td></tr></table></figure><p>Python整数除法除不尽的结果是浮点类型，同时提供了整数除“//”实现余数直接丢掉。Python提供了一个求余的运算%可以计算余数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">11</span> // <span class="number">3</span>)    <span class="comment"># ==&gt; 3 </span></span><br><span class="line">print(<span class="number">11</span> / <span class="number">3</span>)     <span class="comment"># ==&gt; 3.6666666666666665 </span></span><br><span class="line">print(<span class="number">11</span> % <span class="number">3</span>)    <span class="comment"># ==&gt; 2 </span></span><br><span class="line">print(<span class="number">11.0</span> / <span class="number">3</span>)   <span class="comment"># ==&gt; 3.0 </span></span><br><span class="line">print(<span class="number">11</span> ** <span class="number">2</span>)    <span class="comment"># ==&gt; 121 </span></span><br><span class="line">print(<span class="number">10</span> ** <span class="number">0.5</span>) <span class="comment"># ==&gt; 3.1622776601683795</span></span><br></pre></td></tr></table></figure><p><img src="https://xtlei.oss-cn-hongkong.aliyuncs.com/python/python3.png" alt=" "></p><h4 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h4><p>字符串是以&#39;或&quot;括起来的任意文本，比如&#39;abc&#39;，&quot;xyz&quot;等等。请注意，&#39;或&quot;本身只是一种表示方式，不是字符串的一部分，因此，字符串&#39;abc&#39;只有a，b，c这3个字符。（注意：<strong>Python不区分单引号和双引号</strong>）</p><h4 id="四、布尔值"><a href="#四、布尔值" class="headerlink" title="四、布尔值"></a>四、布尔值</h4><p>布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，<strong>在Python中，可以直接用True、False表示布尔值</strong>，也可以通过布尔运算计算出来。</p><p>and运算（与运算），只有所有都为True，and运算结果才是True。<br>or运算（或运算），只要其中有一个为True，or运算结果就是True。<br>not运算（非运算），把True变成False，False变成 True。 </p><p>在Python中，布尔类型还可以与其他数据类型做and、or和not运算，请看下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="literal">True</span> </span><br><span class="line"><span class="keyword">print</span> (a <span class="keyword">and</span> <span class="string">'a=T'</span> <span class="keyword">or</span> <span class="string">'a=F'</span>)  <span class="comment"># a=T </span></span><br><span class="line">print(<span class="literal">True</span> <span class="keyword">and</span> &#123;<span class="string">'tom'</span>&#125;)  <span class="comment">#&#123;'tom'&#125;</span></span><br></pre></td></tr></table></figure><p>计算结果不是布尔类型，而是字符串&#39;a=T&#39;，因为<strong>Python把0、空字符串’’和None看成False，其他数值和非空字符串都看成True</strong>，所以True and &#39;a=T&#39;计算结果是&#39;a=T&#39;，继续计算&#39;a=T&#39; or &#39;a=F&#39;计算结果还是&#39;a=T&#39;。</p><p>要解释上述结果，又涉及到<strong>and和or运算的一条重要法则：短路计算。</strong><br>1.在计算a and b时，如果a是False，则根据与运算法则，整个结果必定为 False，因此返回a；如果a是True，则整个计算结果必定取决与b，因此返回b。<br>2.在计算a or b时，如果a是True，则根据或运算法则，整个计算结果必定为 True，因此返回a；如果a是False，则整个计算结果必定取决于b，因此返回 b。</p><p><strong>Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果。需要注意的是，字典和集合类型不能进行布尔测试，但是上述代码第三行在进行布尔运算时，会产生误导结果。</strong></p><h4 id="五、空值"><a href="#五、空值" class="headerlink" title="五、空值"></a>五、空值</h4><p><strong>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</strong></p><p>此外，Python还提供了复数类型、列表、字典等多种数据类型，还允许创建自定义数据类型。</p></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;h4 id=&quot;一、整数&quot;&gt;&lt;a href=&quot;#一、整数&quot; class=&quot;headerlink&quot; title=&quot;一、整数&quot;&gt;&lt;/a&gt;一、整数&lt;/h4&gt;&lt;p&gt;Python可以处理任意大小的整数，当然包括负整数，在Python程序中，整数的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="软件开发" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="Basis" scheme="https://xtlei.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/Basis/"/>
    
    
      <category term="Python基础" scheme="https://xtlei.github.io/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
      <category term="数据类型" scheme="https://xtlei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>中国古典文学史之清诗清词</title>
    <link href="https://xtlei.github.io/2020/03/14/%E4%B8%AD%E5%9B%BD%E5%8F%A4%E5%85%B8%E6%96%87%E5%AD%A6%E5%8F%B2%E7%95%A5%E4%B9%8B%E6%B8%85%E8%AF%97%E6%B8%85%E8%AF%8D/"/>
    <id>https://xtlei.github.io/2020/03/14/%E4%B8%AD%E5%9B%BD%E5%8F%A4%E5%85%B8%E6%96%87%E5%AD%A6%E5%8F%B2%E7%95%A5%E4%B9%8B%E6%B8%85%E8%AF%97%E6%B8%85%E8%AF%8D/</id>
    <published>2020-03-14T14:48:46.069Z</published>
    <updated>2020-03-31T07:41:06.601Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><h4 id="一、清诗概述"><a href="#一、清诗概述" class="headerlink" title="一、清诗概述"></a>一、清诗概述</h4><p>唐宋诗歌各有特色，元明两代文学转向戏曲、小说，诗歌严重衰落。清代诗人，借鉴前代，扬长补短，推动了古典诗歌的发展。<a id="more"></a>总的看来，清代诗人不满于元诗的绮弱，明诗的复古、轻浅、狭窄的毛病，在技巧上兼学唐宋诗的长处，不断追求创新，反映社会现实，流派迭出，风格多样，其成就是远远超过元明两代，足以成为中国古典诗歌的后劲。</p><p>清朝初期：清初诗坛的主流是“遗民诗”。以明臣而仕清的二臣诗人，最著名的是钱谦益、吴伟业、龚鼎孳(zī)，称“江左三大家”。<br>康雍时期：一流诗人应推王士禛，作诗提倡“神韵”，是“神韵派”的领袖。和王士禛齐名的朱彝尊，是著名学者，作诗才力宏富，但独创新貌不如王士禛。这时期堪与王士禛并称为第一流诗人的，应推查慎行，用笔劲炼，运思刻入，不流于滑易，讲究音节色泽，又兼得唐诗的好处。<br>乾隆时期：乾隆朝的重臣沈德潜作诗注重“格调”，被称为“格调派” 。能开新格局的是袁枚和赵翼。袁、赵和蒋士铨合称“乾隆三大家”。黄景仁是一个早熟而短命的诗人，诗才极高，兼有“清窃之思”和“雄宕之气”，读起来使人回肠荡气，堪称清诗第一大家。<br>乾隆以后：从总的趋势看，已逐渐走向下坡路。  </p><h4 id="二、诗人钱谦益"><a href="#二、诗人钱谦益" class="headerlink" title="二、诗人钱谦益"></a>二、诗人钱谦益</h4><p>钱谦益（1582-1664），字受之，号牧斋，晚号蒙叟，后又号绛云老人、敬他老人、东涧遗老，江苏常熟人。万历三十八年进士，授编修，东林党领袖。崇祯元年任礼部侍郎，翰林侍读学士，后被革职。南明弘光朝，为礼部尚书，清兵南下，率先迎降，为明清之际诗坛宗主。</p><p>乾隆 《钦定国史贰臣表传》<br>诏曰：朕思此等大节有亏之人，不能念其建有勋绩，谅于生前；亦不能因其尚有后人，原于既死。今为准情酌理，自应于国史内另立《贰臣传》一门，将诸臣仕明及仕本朝名事迹，据实直书，使不能纤微隐饰，即所谓虽孝子慈孙百世不能改者。此实乃朕大中至正之心，为万世臣子植纲常！</p><p>钱谦益学问渊博，泛览子、史、文籍与佛藏。论文论诗，反对明代复古派的模拟、竟陵派的狭窄、公安派的肤浅。他一面倡“情真”、“情至”以反对模拟，一面倡学问以反对空疏。他的文章，常把铺陈学问与抒发思想性情糅合起来，纵横曲折，奔放恣肆，合“学人之文”与“文人之文”为一体，规模宏大，振作了明末清初的文风。<br>钱谦益的诗初学盛唐，后广泛学习唐宋各名家，转益多师，不拘一格，才学兼资，藻思洋溢。明亡以后的诗篇，寄寓沧桑身世之感，哀感顽艳与激楚苍凉合而为一，被称为“虞山诗派”的领袖。著有《初学集》《有学集》《投笔集》《苦海集》等，又有《列朝诗集》《杜诗笺注》等。</p><p>柳如是（1618-1664），浙江嘉兴人，名杨爱、杨云娟、杨影怜，后改名柳隐，字如是，号河东君。柳如是是著名歌妓才女，幼即聪慧好学，但由于家贫，从小就被掠卖到吴江为婢，妙龄时坠入章台，易名柳隐，在乱世风尘中往来于江浙金陵之间。<br>柳如是颇有文采，诗稿存有《湖上草》等。<br>钱谦益大柳如是36岁。<br>钱氏娶柳后，为她在虞山盖了壮观华丽的“绛云楼”和“红豆馆”，金屋藏娇。柳氏后生有一女。有“红学”者认为，曹雪芹设计的绛云轩是来自柳氏的绛云楼。<br>本朝第一史学家陈寅恪先生著有《柳如是别传》。</p><p>后秋兴之十三·七律·清·钱谦益<br>海角崖山一线斜，从今也不属中华。<br>更无鱼腹捐躯地，况有龙涎泛海槎。<br>望断关河非汉帜，吹残日月是胡笳。<br>嫦娥老大无归处，独倚银轮哭桂花。</p><h4 id="三、诗人顾炎武"><a href="#三、诗人顾炎武" class="headerlink" title="三、诗人顾炎武"></a>三、诗人顾炎武</h4><p>顾炎武（1613-1682），思想家、学者、诗人，初名绛，字宁人，江苏昆山人，学者称亭林先生。<br>清兵入关后，顾炎武投入南明朝廷，任兵部司务，把复仇的希望寄托在弘光小朝廷之上，撰成《军制论》《形势论》《田功论》《钱法论》，即著名的“乙西四论”。<br>顺治二年，南京即为清兵攻占，顾炎武和挚友归庄等投笔从戎，加入义军。<br>常熟陷落后，顾炎武嗣母王氏闻变，绝食殉国，临终嘱咐炎武，说：“我虽妇人，身受国恩，与国俱亡，义也。汝无为异国臣子，无负世世国恩，无忘先祖遗训，则吾可以瞑于地下。”（《先妣王硕人行状》）此后四五年中，顾炎武奔走于各股抗清力量之间，意图纠合各地义军伺机而动。<br>顺治十四年，炎武晋谒孝陵。7年之间，炎武共六谒孝陵，以寄故国之思，然后返昆山，将家产尽行变卖，从此掉首故乡，一去不归。<br>此后20多年间，炎武孑然一身，游踪不定，足迹遍及山东、河北、山西、河南诸边塞，考察山川形势，以为恢复故国做准备，倡“天下兴亡，匹夫有责”，拒清不仕。<br>学问博洽，于国家典制、郡邑掌故、天文仪象、河漕兵农、经史百家、音韵训诂均有研究。晚年治经侧重考证，开清代朴学风气。认为言志为诗之本，观民风为诗之用。</p><p>悼亡·七绝·清·顾炎武<br>贞姑马鬣在江村，送汝黄泉六岁孙。<br>地下相逢告父姥，遗民犹有一人存。</p><p>白下·七律·清·顾炎武<br>白下西风落叶侵，重来此地一登临。<br>清笳皓月秋依垒，野烧寒星夜出林。<br>万古河山应有主，频年戈甲苦相寻。<br>从教一掬新亭泪，江水平添十丈深。</p><p>海上·七律·清·顾炎武<br>日入空山海气侵，秋光千里自登临。<br>十年天地干戈老，四海苍生吊哭深。<br>水涌神山来白鸟，云浮仙阙见黄金。<br>此中何处无人世，只恐难酬烈士心。 </p><h4 id="四、诗人吴伟业"><a href="#四、诗人吴伟业" class="headerlink" title="四、诗人吴伟业"></a>四、诗人吴伟业</h4><p>吴伟业(1609-1672)，字骏公，号梅村，太仓人。崇祯四年以会试第一，廷试第二中进士，授翰林编修，后任东宫讲读官、南京国子监司业等职。南明福王时，拜少詹事，因与马士英、阮大铖不合，仅任职两月便辞官归里。<br>清朝顺治十年，被迫赴京出仕。初授秘书院侍讲，后升国子监祭酒。常以仕清为恨，为诗坛风云人物。<br>诗中曾云：“我本淮王旧鸡犬，不随仙去落人间”，“浮生唯欠只一死，尘世无由识九还”。七言歌行更为出色，以《圆圆曲》为代表。《四库全书总巨》评：“格律本乎四杰，而情韵为深。叙述类乎香山，而风华为胜。”与钱谦益、龚鼎孳并称“江左三大家”，又为娄东诗派开创者。后人称之为“梅村体”。<br>著作有《梅村家藏稿》《梅村诗余》等。诗今存1000多首。</p><p>自叹·七律·清·吴伟业<br>误尽平生是一官，弃家容易变名难。<br>松筠敢厌风霜苦，鱼鸟犹思天地宽。<br>鼓枻有心逃甫里，推车何事出长干？<br>旁人休笑陶弘景，神武当年早挂冠。</p><h4 id="五、诗人查慎行"><a href="#五、诗人查慎行" class="headerlink" title="五、诗人查慎行"></a>五、诗人查慎行</h4><p>查慎行(1650-1727)，初名嗣琏，字夏重，后改名慎行，字悔余，号他山，又号初白，海宁人。<br>康熙四十二年进士；特授翰林院编修，入直内廷。查慎行经史受业于著名学者黄宗羲，诗法受业于桐城诗人钱澄之，又与朱彝尊为表兄弟，得其奖誉，声名早著。<br>其论诗主张“诗之厚，在意不在辞；诗之雄，在气不在直；诗之灵，在空不在巧；诗之淡，在脱不在易”（清查为仁《莲坡诗话》。袁枚《论诗绝句》称其诗“一味白描神活现，画中谁似李龙眠。”赵翼《瓯北诗话》认为：“梅村后，欲举一家列唐宋诸公之后者，实难其人。惟查初白才气开展，工力纯熟。”查慎行的诗“平生所作，不下万首”（清许汝霖《敬业堂诗集序》），后经他删定为4600余篇。 </p><p>雨过桐庐·七律·清·查慎行<br>江势西来弯复弯，乍惊风物异乡关。<br>百家小聚还成县，三面无城却倚山。<br>帆影依依枫叶外，滩声汩汩碓床间。<br>雨蓑烟笠严陵近，惭愧清流照客颜。</p><p>三闾祠作者·七律·清·查慎行<br>平远江山极目回，古祠漠漠背城开。<br>莫嫌举世无知己，未有庸人不忌才。<br>放逐肯消亡国恨？岁时犹动楚人哀！<br>湘兰沅芷年年绿，想见吟魂自往来。 </p><h4 id="六、诗人赵翼"><a href="#六、诗人赵翼" class="headerlink" title="六、诗人赵翼"></a>六、诗人赵翼</h4><p>赵翼(1727-1814)，字云崧，一字耘崧，号瓯北，常州阳湖人。乾隆十五年举乡试。乾隆十九年27岁，中明通榜，用内阁中书入直军机处，进奉文字，多出其手。乾隆二十六年廷试榜眼，授翰林院编修。乾隆五十二年，两广总督李侍尧平台湾林爽文之乱，以翼筹画之力为多。晚岁主讲安定书院。他重视诗家的创新，立论比较全面、允当。存诗4800多首，以五言古诗最有特色。有诗集53卷及《瓯北诗话》。   </p><p>后园居诗·五古·清·赵翼<br>有客忽叩门，来送润笔需。<br>乞我作墓志，要我工为谀。<br>言政必龚黄，言学必程朱。<br>吾聊以为戏，如其意所需。<br>补缀成一篇，居然君子徒。<br>核诸其素行，十钧无一铢。<br>此文倘传后，谁复知贤愚？<br>或且引为据，竟入史册摹，<br>乃知青史上，大半也属诬。 </p><h4 id="七、诗人黄景仁"><a href="#七、诗人黄景仁" class="headerlink" title="七、诗人黄景仁"></a>七、诗人黄景仁</h4><p>黄景仁(1749-1783)，字汉镛，一字仲则，号鹿菲子，武进人。为清第一诗人。15岁应童子试，三千人中名列第一，16岁补博士弟子员，但从此屡应乡试都不中。</p><p>乾隆三十一年，于江阴遇同邑洪亮吉，时称“洪黄”，成为终生莫逆之交。<br>乾隆三十三年，黄景仁开始浪游浙江、安徽、江西、湖南等地。曾在湖南按察使王太岳、太平知府沈业富、安徽学政朱筠幕中为客。在朱筠幕，于采石矶的太白楼宴会上即席所赋《笥河先生偕宴太白楼醉中作歌》诗传诵一时。<br>乾隆四十年，赴北京，次年应乾隆帝东巡召试取二等，授武英殿书签官。33岁时，游西安，客陕西巡抚毕沅幕。明年回京师，为候补丞，未补官。<br>乾隆四十八年，为债家所迫，抱病再赴西安，至山西解州运城，病逝于河东盐运使沈业富官署中。 </p><p>黄景仁短暂的一生，大都是在贫病愁苦中度过的。<br>所作诗歌，多抒发穷愁不遇、寂寞凄怆的情怀。<br>感遇诗：低沉苍凉；爱情诗：缠绵悱恻；<br>抒怀诗：慷慨豪迈；山水诗：细致生动；<br>怀古咏：别出新意。</p><p>清翁方纲曾为黄景仁的诗集作序说：“故其为诗，能诣前人所未造之地，凌、厉、奇、矫，不主故常。”<br>洪亮吉为黄景仁写《行状》说：“自湖南归，诗益奇肆，见者以为谪仙人复出也。后始稍稍变其体，为王李高岑，为宋元祐诸君子，又为杨诚斋，卒其所诣，与青莲最近。”<br>王昶为黄景仁写《墓志铭》说：“上自汉魏，下逮唐宋，无弗效者，疏瀹灵腑，出精入能，刻琢沉挚，不以蹈袭剽窃为能。” </p><p>黄景仁亦能词，词作明白晓畅，擅长白描，但含蓄不够。<br>著作有《两当轩集》22卷，其中诗16卷，词3卷,诗词补遗及遗文3卷。 </p><p>笥河先生偕宴太白楼醉中作歌·歌行·清·黄景仁<br>红霞一片海上来。照我楼上华筵开。<br>倾觞绿酒忽复尽。楼上谪仙安在哉。<br>谪仙之楼楼百尺。笥河夫子文章伯。<br>风流仿佛楼中人。千一百年来此客。<br>是日江山同云开。天门淡扫双娥眉。<br>江从慈母矶边转。潮到然犀亭下回。<br>青山对面客起舞。彼此青莲—抔土。<br>若论七尺归蓬蒿。此楼做客山是主。<br>若论醉月来江滨。此楼作主山作宾。<br>长星动摇若无色。未必长作人间魂。<br>身后苍凉尽如此。俯仰悲歌亦徒尔。<br>杯底空馀今古愁。眼前忽尽东南美。<br>高会题诗最上头。姓名未死重山丘。<br>请将诗卷掷江水。定不与江东向流。</p><p>癸巳除夕偶成二首其一·七绝·清·黄景仁<br>千家笑语漏迟迟。忧患潜从物外知。<br>悄立市桥人不识。一星如月看多时。</p><p>别老母·七绝·清·黄景仁<br>搴帷别母河梁去。白发愁看泪眼枯。<br>惨惨柴门风雪夜。此时有子不如无。</p><p>倚怀十六其六 ·七律·清·黄景仁<br>小极居然百媚生。懒抛金叶罢调筝。<br>心疑棘刺针穿就。泪似桃花醋酿成。<br>会面生疏稀笑靥。别筵珍重赠歌声。<br>沈郎莫叹腰围减。忍见青娥绝塞行。</p><p>太白墓·歌行·清·黄景仁<br>束发读君诗。今来展君墓。<br>清风江上洒然来。我欲因之寄微慕。<br>呜呼。有才如君不免死。我固知君死非死。<br>长星落地三千年。此是昆明劫灰耳。<br>高冠岌岌佩陆离。纵横击剑胸中奇。<br>淘熔屈宋入大雅。挥洒日月成瑰词。<br>当时有君无著处。即今遣蠋犹相思。<br>醒时兀兀醉千首。应是鸿濛借君手。<br>乾坤无事入怀抱。只有求仙与饮酒。<br>一生低首帷宣城。墓门正对青山青。<br>风流辉映今犹昔。更有灞桥驴背客。<br>此间地下真可观。怪底江山总生色。<br>江山终古月明里。醉魄沉沉呼不起。<br>锦袍画舫寂无人。隐隐歌声绕江水。<br>残膏剩粉洒六合。犹作人间万余子。<br>与君同时杜拾遗。窆石却在潇湘湄。<br>我昔南行曾访之。衡云惨惨通九疑。<br>即论身后归骨地。俨与诗境同分驰。<br>终嫌此老太愤激。我所师者非公谁。<br>人生百年要行乐。一日千杯苦不足。<br>笑看樵牧语斜阳。死当埋我兹山麓。</p><p>杂感·七律·清·黄景仁<br>仙佛茫茫两未成，只知独夜不平鸣。<br>风蓬飘尽悲歌气，泥絮沾来薄幸名。<br>十有九人堪白眼，百无—用是书生。<br>莫因诗卷愁成谶，春鸟秋虫自作声。</p><h4 id="八、清词概述"><a href="#八、清词概述" class="headerlink" title="八、清词概述"></a>八、清词概述</h4><p>如果我们将唐词比作镶着露珠的晨曦，将宋词比作披着云锦的丽日，那么，清词就是流金溢彩、光怪陆离的晚霞了。<br>明亡后，以一大批遗民词人为代表，论时代虽已入清，但窜伏草野、抱贞守节，不向新朝臣服。<br>努尔哈赤自小就养于明代守辽名将李成梁帐下，通晓汉文，满清之初即已略被汉风。入关后，一方面镇压，一方面大行儒家政教，谋求合作与支持。作为一个少数民族所建立的王朝，清代的政治寿命之所以能两三倍于金、元而与唐、宋、明大体持平，清代的学术文化包括词的创作之所以能突过金、元、明而比隆于唐、宋，这不能不说是一个重要的关键。再有大凡一种文体，盛极而衰，剥久必复，此乃自然之理。<br>清前期康熙年间为词学创作的一大高峰。此时阳羡、浙西二派犄角对接，陈维崧、朱彝尊、纳兰性德鼎足三分，清词中兴，大势既成。阳羡词派，取法南宋辛弃疾及宋末阳羡名家蒋捷，悲壮淋漓，权奇恢诡，其领袖人物暨典范作家为陈维崧。浙西词派的兴起稍晚于阳羡词派，但持续的时间较长，反映的社会生活面偏窄，内容贫乏，此派的开山祖师朱彝尊。<br>康熙十八年大多数汉族知识分子承认和接受了现实，反清的民族意识渐趋淡化。此期词坛还涌现了一批专学唐、五代、北宋言情小令的作家，出类拔萃者为优秀的满族词人纳兰性德。<br>自三家之后，不见出类拔萃者。</p><h4 id="九、词家陈维崧"><a href="#九、词家陈维崧" class="headerlink" title="九、词家陈维崧"></a>九、词家陈维崧</h4><p>陈维崧（1625-1682），字其年，号迦陵，宜兴人。清初诸生，幼有神童之誉，长而才名益著，意气若云，当世名流，无不酬唱订交。吴伟业曾誉之为“江左凤凰”。康熙十八年举博学鸿词，授翰林院检讨，参与修纂《明史》，4年后卒于任所。<br>入清后流离颠沛，“饥驱四方，或驴背清霜，孤篷夜雨；或河梁送别，千里怀人；或酒旗歌板，须髯奋张；或月榭风廊，肝肠掩抑；一切诙谐狂啸、细泣幽吟，无不寓之于词”(清陈维岳《湖海楼词序》)。<br>一生作词四百余调、千六百首有奇,《陈迦陵集》五十四卷，如是之富，绝后空前。以豪放为主，兼有清真娴雅之作。清陈廷焯《白雨斋词话》说：“国初词家，断以迦陵为巨擘”,“迦陵词气魄绝大，骨力绝遒，填词之富，古今无两”，或谓“不及稼轩之浑厚沉郁”。<br>布阵图而战旷野，稼轩慢词之森严，其年不能遽敌；然持短兵而斗狭巷，以纵横捭阖之辞游刃有余于小令，则是他的长技。<br>更难得的是陈维崧各体词都写得很出色。陈维崧词的缺点是有时倾泻过甚，一发无余，便缺余蕴，稍嫌轻率。 </p><p>南乡子(邢州道上作)·词·清·陈维崧<br>秋色冷并刀。一派酸风卷怒涛。并马三河年少客，粗豪。皂栎林中醉射雕。<br>残酒忆荆高。燕赵悲歌事未消。忆昨车声寒易水，今朝。慷慨还过豫让桥。</p><p>醉落魄（咏鹰）·词·清·陈维崧<br>寒山几堵，风低削碎中原路。秋空一碧无今古。醉袒貂裘，略记寻呼处。<br>男儿身手和谁赌？老来猛气还轩举。人间多少闲狐兔。月黑沙黄，此际偏思汝。</p><p>贺新郎(送邵兰雪归吴门仍用前韵)·词·清·陈维崧<br>易水严装发。休回首。故人别酒。帝城高阙。九曲黄河迎马首。渺渺龙宫堆雪。流不尽。天涯白月。君去故侯瓜可种。向西风。莫短冲冠发。人世事。总毫末。<br>长州鹿走苏台折。叹年少。当歌不醉。此非俊物。试到吴东门下问。可有吹箫人杰。有亦被。怒潮磨灭。来夜天街无酒伴。怕离鸿。叫得枫成血。亦归耳。住何益。 </p><h4 id="十、词家朱彝尊"><a href="#十、词家朱彝尊" class="headerlink" title="十、词家朱彝尊"></a>十、词家朱彝尊</h4><p>朱彝尊(1629-1709)，字锡鬯，号竹垞，又号金风亭长，晚称小长芦钓师，浙江嘉兴人。康熙十八年举科博学鸿词，以布衣授翰林院检讨，入直南书房，曾参加纂修《明史》。<br>擅长诗词古文，词宗姜夔、张炎，风格清丽，为浙派词人的创始者。朱彝尊青壮年时曾落拓江湖，又与妻妹有过一段被扼杀的恋情。集中不乏雄浑苍莽的吊古之作、哀感顽艳的怀人之什，英雄气、儿女情兼而有之。</p><p>解珮令(自题词集)·词·清·朱彝尊<br>十年磨剑，五陵结客，把平生，涕泪都飘尽。老去填词，一半是，空中传恨。几曾围，燕钗蝉鬓。<br>不师秦七，不师黄九，倚新声，玉田差近。落拓江湖，且分付，歌筵红粉。料封侯，白头无分。</p><h4 id="十一、词家纳兰性德"><a href="#十一、词家纳兰性德" class="headerlink" title="十一、词家纳兰性德"></a>十一、词家纳兰性德</h4><p>纳兰性德(1654-1685)原名成德，字容若，号楞伽山人，满州正黄旗人。太学士明珠长子。所交皆一时隽异。清杨芳灿《纳兰词序》评 ：“骚情古调，侠肠隽骨，隐隐奕奕，流露于豪楮间”。“盖其三生慧业，不耐浮尘，寄思无端，抑郁不释，韵淡疑仙，思幽近鬼，年之不永，即兆于斯。</p><p>南乡子(为亡妇题照)·词·清·纳兰性德<br>泪咽却无声。只向从前悔薄情。凭仗丹青重省识。盈盈。一片伤心画不成。<br>别语忒分明。午夜鹣鹣梦早醒。卿自早醒侬自梦。更更。泣尽风檐夜雨铃。</p><p>蝶恋花·词·清·纳兰性德<br>辛苦最怜天上月。一昔如环，昔昔都成玦。若似月轮终皎洁，不辞冰雪为卿热。<br>无那尘缘容易绝。燕子依然，软踏帘钩说唱罢秋坟愁未歇，春丛认取双栖蝶。</p><h4 id="附：古典诗论"><a href="#附：古典诗论" class="headerlink" title="附：古典诗论"></a>附：古典诗论</h4><h5 id="（一）文心雕龙"><a href="#（一）文心雕龙" class="headerlink" title="（一）文心雕龙"></a>（一）文心雕龙</h5><p>《文心雕龙》在古今文论中时临尽早非最早，而力宏大至今难有敌者，先前有曹丕的《典论·论文》，陆机的《文赋》等，最终功皆由斯书覆掩。《文心雕龙》是一部总结性的文学批评巨著。文体为骈。空前绝后。<br>作者刘勰(466?-520?)。字彦和，祖籍东莞莒。世居京口，早孤笃志好学。家贫不能婚，依名僧十载，博通佛经且参与态理。梁以后作过记室、参军等为小官。并兼东宫通事舍人，深得太子萧统器重。晚年出家，更名慧地，不久而亡。<br>《文心雕龙》是刘勰三十几岁时的作品，创作于齐代，以儒家思想为基。人生观如书中所言：“穷则独善以垂文，达则奉时以骋绩。注重文章的政治社会作用，他写这部书的目的是为了纠正离开了经典本源的南朝的“浮诡”“讹烂”的文风。<br>《文心雕龙》五十篇，总论五篇，自《原道》第一始，论“文之枢纽”。文体论二十篇，自《明诗》第六起。创作论十九篇，自《神思》二十六始。批评论五篇，自《时序》第四十五始，也是全书的精彩部分。最后一篇《序志》第五十。全书观点主要体现在以下几个方面<br>(一)、初步建立用历史的眼光来分析、评论文学的观点。<br>(二)、他从不同角度阐发了质先于文、质文并重的文学主张。<br>(三)、从创作的各个环节各个方面总结了创作的经验。阐明文人所必备的才、气、学、习。<br>(四)、建立了文学批评的方法论。<br>《文心雕龙》在文论中是空前绝后的。</p><p>文心雕龙序志第五十(有删节)·骈文·南朝梁·刘勰<br>夫铨序一文为易，弥纶群言为难，虽复轻采毛发，深极骨髓，或有曲意密源，似近而远，辞所不载，亦不可胜数矣。<br>及其品列成文，有同乎旧谈者，非雷同也，势自不可异也；有异乎前论者，非苟异也，理自不可同也。同之与异，不屑古今，擘肌分理，唯务折衷。</p><p>文心雕龙风骨第二十八(有删节)·骈文·南朝梁·刘勰<br>《诗》总六义，风冠其首；斯乃化感之本源，志气之符契也。是以怊怅述情，必始乎风；沈吟铺辞，莫先于骨。故辞之待骨，如体之树骸；情之含风，犹形之包气。结言端直，则文骨成焉；意气骏爽，则文风清焉。<br>若丰藻克赡，风骨不飞，则振采失鲜，负声无力。是以缀虑裁篇，务盈守气，刚健既实，辉光乃新。其为文用，譬征鸟之使翼也。<br>故练于骨者，析辞必精；深乎风者，述情必显。捶字坚而难移，结响凝而不滞，此风骨之力也。<br>若瘠义肥辞，繁杂失统，则无骨之征也。思不环周，索莫乏气，则无风之验也。能鉴斯要，可以定文；兹术或违，无务繁采。<br>夫翚翟备色，而翾翥百步，肌丰而力沈也；鹰隼乏采，而翰飞戾天，骨劲而气猛也。文章才力，有似于此。<br>若风骨乏采，则鸷集翰林；采乏风骨，则雉窜文囿。唯藻耀而高翔，固文笔之鸣凤也。<br>若夫熔铸经典之范，翔集子史之术；洞晓情变，曲昭文体；然后能孚甲新意，雕画奇辞。昭体，故意新而不乱，晓变，故辞奇而不黩。若骨采未圆，风辞未练，而跨略旧规，驰骛新作，虽获巧意，危败亦多；岂空结奇字，纰缪而成经矣？</p><p>文心雕龙明诗第六(有删节)·骈文·南朝梁·刘勰<br>人禀七情，应物斯感，感物吟志，莫非自然。慷慨以任气，磊落以使才；造怀指事，不求纤密之巧；驱辞逐貌，唯取昭晰之能。诗有恒裁，思无定位，随性适分，鲜能通圆。若妙识所难，其易也将至；忽以为易，其难也方来。</p><h5 id="（二）钟嵘诗品"><a href="#（二）钟嵘诗品" class="headerlink" title="（二）钟嵘诗品"></a>（二）钟嵘诗品</h5><p>钟嵘，字仲伟，颍川长社人，生卒年不详。其在齐梁时代曾作过参军，记室等小官。《诗品》是梁武帝天监十二年以后写成的。钟嵘时代，诗风衰落严重：“庸音杂体，人各为容 ”，十分混乱。故仿汉代“九品论人，七略裁士的原则。<br>全书将两汉至梁作家122人，分为上、中、下三品进行评论，故名为《诗品》。计上品11人，中品39人，下品72人。<br>钟嵘对诗歌创作中的一些重要问题正面提出了自己的见解：<br>一，他继西晋陆机《文赋》及《文心雕龙》之后更明确地提出了诗的“滋味”问题。<br>二，关于“真美”的原则。强调诗歌创作要“真美”。“真美”就是要求诗歌创作要有真挚强烈的感情，而非虚假的无病呻吟。<br>三，他提出诗歌创作应该“指事造形，穷情写物”，要求“穷情”和“写物”很好地结合起来。<br>要求赋比兴相济为用。且对内风力外丹采同等重视。<br>钟嵘论诗还坚决反对沈约等人四声八病的主张。 </p><p>曹植：骨气奇高，词采华茂，情兼稚怨，体被文质，粲溢今古，卓尔不群。（上）<br>王粲：其源出於李陵。发愀怆之词，文秀而质羸。在曹、刘间别构一体。方陈思不足，比魏文有馀。（上）<br>鲍照：得景阳之叔诡，含茂先之靡嫚。骨节强于谢混，驱迈疾于颜延，总四家而擅美，跨两代而孤出。（中）<br>陶潜：文体省净，殆无长语。笃意真古，辞兴婉惬。每观其文，想其人德。世叹其质直。古今隐逸诗人之宗也。（中）<br>曹操：曹公古直，甚有悲凉之句。（下）</p><h5 id="（三）诗品二十四"><a href="#（三）诗品二十四" class="headerlink" title="（三）诗品二十四"></a>（三）诗品二十四</h5><p>司空图(837-908)，字表圣，河中虞乡人。于唐懿宗咸通十年应试，擢进士，名声益振。官至礼部员外郎。<br>唐僖宗广明元年，黄巢起义军攻入长安。司空图到凤翔见驾，被封为知制诰、中书舍人。 55岁辞官归乡隐居。朱温称帝，招其为官，其忠于唐室，坚辞不就，闻唐衰帝被杀，不食而死。<br>《诗品二十四》：<br>从审美态度论风格的有：雄浑、沉著、冲洗、纤秾、高古、典雅，劲健、绮丽、自然、豪放、疏野、清奇、悲慨、飘逸、旷达。从语言着眼论风格的有：洗炼。从结构着眼论风格的有：缜密，委曲。从素养技巧论风格的有：精神、实境、含蓄、形容、超诣、流动。<br>两家《诗品》欲分别：前者是品诗，后者是诗品。<br>司空诗品的最大优点是因诗论品，因品论人。 </p><p>诗品雄浑第一·四言诗·唐·司空图<br>大用外腓。真体内充。返虚入浑。积键为雄。<br>具备万物。横绝长空。荒荒油云。寥寥长风。<br>超以象外。得其环中。持之匪强。来之无穷。</p><p>诗品典雅第六·四言诗·唐·司空图<br>玉壶买春。赏雨茅屋。坐中佳士。左右修竹。<br>白云初晴。幽鸟相逐。眠琴绿荫。上有飞瀑。<br>落花无言。人淡如菊。书之岁华。其曰可读。</p><p>诗品豪放第十二·四言诗·唐·司空图<br>观花匪禁。吞吐大荒。由道返气。处得以狂。<br>天风浪浪。海山苍苍。真力弥满。花时返旁。<br>前招三辰。后引凤凰。晓策六鳌。濯足扶桑。</p><h5 id="（四）诗话"><a href="#（四）诗话" class="headerlink" title="（四）诗话"></a>（四）诗话</h5><p>朱熹继承并生展了“文以载道”，主张道是本，文是末，缺乏是不懂得文学的源泉是生活。<br>严羽，字仪卿 ，邵武人，宋末隐居不仕，大概卒于理宗末年，他有《沧浪诗活》最为著名。其中分为“诗辩”“诗体”“诗法”“诗评”“诗正”五部分。</p><p>妙论：“夫诗有别材，非关书也；诗有别趣，非关理也。而古人未尝不读书，不穷理。所谓不涉理路，不落言筌者，上也。诗者，吟咏性情也。盛唐诸人唯有兴趣，羚羊挂角，无迹可求。故其妙处透彻玲珑，不可凑泊，如空中之音，相中之色，水中之月，镜中之像，言有尽而意无穷。”指出苏黄的缺点是：“以文字为诗，以才学为诗，以议论为诗” 。<br>宋之诗话：欧阳修的《六一诗话》，陈师道的《后山诗话》，叶梦得的《石林诗话》，胡仔的《溪渔隐丛话》，魏庆之的《诗人玉屑》，刘克庄的《后村诗话》，陆游的《老学庵笔记》，秦观的《秦少游诗话》，姜夔的《白石道人诗说》等等。<br>金元诗话：方回的《方回文论辑录》，王若虚的《滹南诗话》，李东阳的《怀麓堂诗话》，谢榛的《四溟诗话》等等。<br>明诗话：胡应麟的《诗薮》最为上乘。<br>清诗话：叶燮的《原诗》，王夫之的《薑斋诗话》，袁枚的《随园诗话》，陈延焯的《白雨斋词话》，梁启超的《饮冰室诗话》，王国维的《人间词话》。总论诗、词、曲、赋的是刘熙载的《艺概》。  </p><p>叶燮的《原诗》选数段如下：<br>譬之上古之世，饭土簋，啜土铏，当饮食未具时，进以一脔，必为惊喜；逮后世臛)臇鱼脍之法兴，罗珍搜错，无所不至，而犹以土簋土铏之庖进，可乎？上古之音乐，击土鼓而歌康衢，其后乃有丝、竹、匏、革之制，流至於今，极於九宫南谱。声律之妙，日异月新，若必返古而听击壤之歌，斯为乐乎？<br>大凡物之踵事增华，以渐而进，以至於极。故人之智慧心思，在古人始用之，又渐出之；而未穷未尽者，得后人精求之，而益用之出之。乾坤一日不息，则人之智慧心思必无尽与穷之日。<br>大凡人无才，则心思不出；无胆，则笔墨畏缩；无识，则不能取舍；无力，则不能自成一家。 </p><h5 id="（五）论诗绝句"><a href="#（五）论诗绝句" class="headerlink" title="（五）论诗绝句"></a>（五）论诗绝句</h5><p>杜甫首创，自此以后，作者纷起，体现其内容凝练，辞约意丰，传播广泛，影响深远。缺点是常生歧解，然其力小功巨。</p><p>戏为六绝句(选二)·七绝·唐·杜甫<br>其五：<br>不薄今人爱古人。清词丽句必为邻。<br>窃攀屈宋宜方驾。恐与齐梁作后尘。<br>其六：<br>未及前贤更勿疑。递相祖述复先谁。<br>别裁伪体亲风雅。转益多师是汝师。</p><p>论诗十绝之十·七绝·宋·戴复古<br>草就篇章只等闲。作诗容易改诗难。<br>玉经雕琢方成器。句要丰腴字要安。</p><p>论诗三十绝之二十八·七绝·金·元好问<br>古雅难将子美亲，精纯全失义山真。<br>论诗宁下涪翁拜，未作江西社里人。</p><p>论诗二首·七绝·清·赵翼<br>满眼生机转化钧。天工人巧日争新。<br>预支五百年新意。到了千年又觉陈。<br>结习沉吟老末忘。尚随年少角词场。<br>只愁后世无新意。不敢多搜锦绣肠。</p><p>说诗·七绝·清·宋湘<br>妙语雷同自不知。前贤应恨我生迟。<br>胜他刻意求新巧。做到无人得解时。</p><p>论诗二首·七绝·本朝·褚宝增<br>古人虽死亦当争，不胜古人算枉生。<br>待胜再开新世界，千年得并古人声。<br>并非守旧抱残枝，弃韵终究不是诗。<br>巨斧无痕因匠力，行吟千载后人知。</p><h4 id="以上内容均来自褚宝增老师讲义"><a href="#以上内容均来自褚宝增老师讲义" class="headerlink" title="以上内容均来自褚宝增老师讲义"></a>以上内容均来自褚宝增老师讲义</h4></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;h4 id=&quot;一、清诗概述&quot;&gt;&lt;a href=&quot;#一、清诗概述&quot; class=&quot;headerlink&quot; title=&quot;一、清诗概述&quot;&gt;&lt;/a&gt;一、清诗概述&lt;/h4&gt;&lt;p&gt;唐宋诗歌各有特色，元明两代文学转向戏曲、小说，诗歌严重衰落。清代诗人，借鉴前代，扬长补短，推动了古典诗歌的发展。&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="古典文学" scheme="https://xtlei.github.io/categories/%E5%8F%A4%E5%85%B8%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="古典文学史" scheme="https://xtlei.github.io/tags/%E5%8F%A4%E5%85%B8%E6%96%87%E5%AD%A6%E5%8F%B2/"/>
    
      <category term="诗词" scheme="https://xtlei.github.io/tags/%E8%AF%97%E8%AF%8D/"/>
    
      <category term="清朝" scheme="https://xtlei.github.io/tags/%E6%B8%85%E6%9C%9D/"/>
    
  </entry>
  
  <entry>
    <title>中国古典文学史之明清小说</title>
    <link href="https://xtlei.github.io/2020/03/14/%E4%B8%AD%E5%9B%BD%E5%8F%A4%E5%85%B8%E6%96%87%E5%AD%A6%E5%8F%B2%E7%95%A5%E4%B9%8B%E6%98%8E%E6%B8%85%E5%B0%8F%E8%AF%B4/"/>
    <id>https://xtlei.github.io/2020/03/14/%E4%B8%AD%E5%9B%BD%E5%8F%A4%E5%85%B8%E6%96%87%E5%AD%A6%E5%8F%B2%E7%95%A5%E4%B9%8B%E6%98%8E%E6%B8%85%E5%B0%8F%E8%AF%B4/</id>
    <published>2020-03-14T14:46:53.061Z</published>
    <updated>2020-03-31T07:40:25.956Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><h4 id="一、小说的变迁"><a href="#一、小说的变迁" class="headerlink" title="一、小说的变迁"></a>一、小说的变迁</h4><p>小说的基本特征：以散体文的形式表现叙事性的内容，通过一定的故事情节对人物的关系、命运、行为、思想、情感、环境、心理进行具体的艺术描写。 <a id="more"></a></p><p>《庄子·外物》：夫揭竿累，趣灌渎，守鲵鲋，其于得大鱼难矣。饰小说以干县令，其于大达亦远矣。<br>庄子认为“小说”是琐屑浅薄的言论。<br>东汉桓谭《新论》：“若其小说家，合丛残小语，近取譬譬论，以作短书，治身理家，有可观之辞。”<br>东汉班固《汉书·艺文志》：“小说家者流，盖出于稗官。街谈巷语，道听涂说者之所造也。”</p><p>追溯小说的起源，有以下几种方面：<br>首先是神话传说，其次是寓言故事，再次是史传。<br>中国古代小说滥觞于魏晋的“志怪”（干宝的《搜神记》），南朝宋的“志人”（刘义庆的《世说新语》），唐代的“传奇”（陈鸿的《长恨歌传》、李朝威的《柳毅传》、元缜的《莺莺传》文言体），宋代的“话本”至元时日盛。元末明初出现了我国古典长篇小说的惟一形式——白话章回体，到了清代，小说基本上是文人的创作。   </p><h4 id="二、三国演义"><a href="#二、三国演义" class="headerlink" title="二、三国演义"></a>二、三国演义</h4><p>罗贯中，生卒年不详，据考订，一般认为名本，字贯中。杭州人，祖籍太原。王圻《稗史汇编》谓罗贯中与葛可久“皆有志图王者”。<br>有自己的政治理想，不苟同于流俗，东奔西走，参加反元起义，明朝建立后，即结束了政治生涯，而专心致力于小说创作。<br>相传有《十七史演义》,《三国志通俗演义》它文不甚深，言不甚俗，“据正史，采小说，证文辞，通好尚、非俗非虚，易观易入，非史氏苍古之文，专瞽传诙谐之气，陈叙百年，该括万事”。<br>影响巨大深远，等同历史教科书，军事教科书，生活教科书。结构完整为名著中第一者。综合艺术成就亦是名著中第一者。 </p><p>诸葛亮骂死王朗(自三国演义) ·小说·明·罗贯中<br>朗曰：“久闻公之大名，今幸一会。公既知天命、识时务，何故兴无名之兵？”<br>孔明曰：“吾奉诏讨贼，何谓无名？”<br>朗曰：“天数有变，神器更易，而归有德之人，此自然之理也。曩自桓、灵以来，黄巾倡乱，天下争横。降至初平、建安之岁，董卓造逆，桷、汜继虐；袁术僭号于寿春，袁绍称雄于邺土；刘表占据荆州，吕布虎吞徐郡：盗贼蜂起，奸雄鹰扬，社稷有累卵之危，生灵有倒悬之急。我太祖武皇帝，扫清六合席卷八荒；万姓倾心，四方仰德。非以权势取之，实天命所归也。世祖文帝，神文圣武，以膺大统，应天合人，法尧禅舜，处中国以临万邦，岂非天心人意乎？今公蕴大才、抱大器，自欲比于管、乐，何乃强欲逆天理、背人情而行事耶？岂不闻古人曰：‘顺天者昌，逆天者亡。’今我大魏带甲百万，良将千员。谅腐草之萤光，怎及天心之皓月？公可倒戈卸甲，以礼来降，不失封侯之位。国安民乐，岂不美哉！”<br>孔明在车上大笑曰：“吾以为汉朝大老元臣，必有高论，岂期出此鄙言！吾有一言，诸军静听：昔日桓、灵之世，汉统陵替，宦官酿祸；国乱岁凶，四方扰攘。黄巾之后，董卓、桷、汜等接踵而起，迁劫汉帝，残暴生灵。因庙堂之上，朽木为官，殿陛之间，禽兽食禄；狼心狗行之辈，滚滚当道，奴颜婢膝之徒，纷纷秉政。以致社稷丘墟，苍生涂炭。吾素知汝所行：世居东海之滨，初举孝廉入仕；理合匡君辅国，安汉兴刘；何期反助逆贼，同谋篡位！罪恶深重，天地不容！天下之人，愿食汝肉！今幸天意不绝炎汉，昭烈皇帝继统西川。吾今奉嗣君之旨，兴师讨贼。汝既为谄谀之臣，只可潜身缩首，苟图衣食；安敢在行伍之前，妄称天数耶！皓首匹夫！苍髯老贼！汝即日将归于九泉之下，何面目见二十四帝乎！老贼速退！可教反臣与吾共决胜负！”</p><h4 id="三、水浒传"><a href="#三、水浒传" class="headerlink" title="三、水浒传"></a>三、水浒传</h4><p>关于《水浒传》的作者，明人记载不一，大致有三种说法：施耐庵作，罗贯中作，施罗合作。现学术界大都认为是施耐庵作。<br>施耐庵（1296?-1370?），元末明初人，名子安，字耐庵，原籍钱塘，后迁居兴化。是孔子七十二子弟之一施之常后裔。<br>19岁中秀才，28岁中举人，36岁与刘伯温同榜中进士。张士诚起义抗元时，施耐庵参加了他的军事活动,后因张贪享逸乐，不纳忠言而去。 </p><p>据《东都事略·侯蒙传》：“江以三十六人横行河朔，京东官军数万无敢抗者。”<br>又据《宋史·徽宗本纪》：“淮南盗宋江等犯淮阳军,遣将讨捕，又犯京东、河北，入楚、海州界，命知州张叔夜招降之。”<br>南宋末龚开《宋江三十六人赞并序》说：“宋江事见于街谈巷语。” </p><p>施耐庵正是把这些在不同地区流传的故事，汇集起来，经过选择、加工、再创作，才写成这部优秀的古典名著《水浒传》。<br>《水浒传》说明“官逼民反”，“八方共域，异姓一家”，“杀富济贫”“替天行道”。讲义气，最终被“忠孝”所害。<br>是古典小说人物描写的第一圣手。</p><p>描写卢俊义：目炯双瞳，眉分八字，身躯九尺如银。威风凛凛，仪表似天神。惯使一条棍棒，护身龙、绝技无伦。京城内、家传清白，积祖富豪门。杀场临敌处，冲开万马，扫退千军。更忠肝贯日，壮气凌云。慷慨疏财仗义，论英名、播满乾坤。卢员外，双名俊义，绰号玉麒麟。</p><h4 id="四、西游记"><a href="#四、西游记" class="headerlink" title="四、西游记"></a>四、西游记</h4><p>吴承恩(1500?-1582?)，明人，字汝忠，号射阳山人，先世江苏涟水人，后徙淮安山阳。<br>出身于一个世代书香而败落为小商人的家庭。<br>《西游记》创作的时期不可确考，一般认为是晚年所作。<br>《西游记》的故事经历了一个漫长的演变过程。因为明弘治到万历时代政治腐败，世风堕落，造成了急切呼唤斩邪除妖的英雄的渴望。外国将此书译名为《猴的故事》。语言优美的景物描写是诸名著中第一者。<br>吴承恩一生诗、文、词创作数量不少，但因无子嗣，去世后大部分亡佚。后由“亲犹表孙，义近高弟”的丘度，从亲友中遍索遗稿，但亦仅“存十一于千百”，编订成《射阳先生存稿》4卷,包括诗1卷，散文3卷，末附小词38首。</p><p>《西游记》第一回描写灵台方寸山斜月三星洞：<br>烟霞散彩，日月摇光。千株老柏，万节修篁。千株老柏，带雨半空青冉冉；万节修篁，含烟一壑色苍苍。门外奇花布锦，桥边瑶草喷香。石崖突兀青苔润，悬壁高张翠藓长。时闻仙鹤唳，每见凤凰翔。仙鹤唳时，声振九皋霄汉远；凤凰翔起，翎毛五色彩云光。玄猿白鹿随隐见，金狮玉象任行藏。细观灵福地，真个赛天堂！</p><h4 id="五、金瓶梅"><a href="#五、金瓶梅" class="headerlink" title="五、金瓶梅"></a>五、金瓶梅</h4><p>《金瓶梅》约在明隆庆至万历年间(1567-1620)成书，署名兰陵笑笑生，兰陵今属山东临沂,作者大约是山东人，真名难考。英国汉学家阿瑟·韦利早在20世纪30年代就提出作者应是徐渭，另有王士贞之说。<br>西门庆原是个破落财主、生药铺老板。他善于夤缘钻营、巴结权贵，在县里包揽讼事、交通官吏，知县知府都和他往来。他不择手段地巧取豪夺、聚敛财富、荒淫好色、无恶不作。他抢夺寡妇财产，诱骗结义兄弟的妻子，霸占民间少女，谋杀姘妇的丈夫。为了满足贪得无厌的享乐欲望，他干尽伤天害理的事情。但由于有官府做靠山，当朝宰相蔡京为其义父，这就使他不仅没有遭到应有的惩罚，而且左右逢源、步步高升。<br>《金瓶梅》是中国古代小说发展的里程碑。是第一部以家庭生活和世态人情为题材的长篇小说，为此后的世情小说开辟了广阔的题材世界，又是中国文学史上第一部由文人独创的原创长篇小说。<br>与《三国》《水浒》《西游》并为明代“四大奇书”。<br>《金瓶梅》书名从小说中西门庆的三个妾潘金莲、李瓶儿、庞春梅的名字中各取一字而成。</p><h4 id="六、封神演义"><a href="#六、封神演义" class="headerlink" title="六、封神演义"></a>六、封神演义</h4><p>《封神演义》，明代长篇小说。作者有许仲琳、陆西星两说，都只有孤证，多数认为是许仲琳作。成书年代不可确考,一般认为在明穆宗隆庆至明神宗万历之间。100回,别题《武王伐纣外史》。<br>“实不过假商周之争，自写幻想”（鲁迅《中国小说史略》）。 </p><p>演义以纣王进香，题诗渎神，于是女娲命三妖惑纣助周为楔子，历叙纣王、妲己荒淫暴虐恶行，及姜子牙晚年知遇，西伯侯脱祸归周，武王起兵反商诸事，后纣王自焚，武王克商，而以姜子牙祭坛封神，周武王分封列国告终。<br>《封神演义》通过设炮烙造虿盆、剖孕妇、敲骨髓等情节，描写纣王的残暴不仁。把武王伐纣的“以臣伐君”“以下伐上”处理为“灭独夫”之举。姜子牙主张“天下者，非一人之天下，乃天下人之天下也”，号召诸侯“吊民伐罪”，强调了“父逼子反”、“君逼臣反”而不得不反的精神。<br>但另一方面，书中又充满着“成汤气数已尽，周室当兴”的天命观，每个参加商周之争的人不过是“完天地之劫数，成气运之迁移” 。此外女祸思想“青竹蛇儿口，黄蜂尾上针，两般由自可，最毒妇人心。”更不足取。 </p><h4 id="七、三言"><a href="#七、三言" class="headerlink" title="七、三言"></a>七、三言</h4><p>冯梦龙(1574-1646)，字犹龙，又字子犹，别号龙子犹、墨憨斋主人、顾曲散人、词奴等。长洲(今苏州)人，出身士大夫家庭。兄梦桂善画，弟梦熊为太学生，兄弟三人并称“吴下三冯”。<br>天启六年，冯梦龙被迫害，冯梦龙发愤著书，完成《喻世明言》（旧题《古今小说》）《警世通言》《醒世恒言》的编纂工作和《古今谭概》《太平广记钞》《智囊》《情史》《太霞新奏》等的评纂工作。<br>崇祯三年取得贡生资格，任丹徒县训导，七年升福建寿宁知县。崇祯十一年64岁秩满离任,归隐乡里。晚年仍孜孜不倦,继续从事小说创作和戏曲整理研究工作。崇祯十七年，李自成推翻明王朝，冯梦龙悲痛欲绝，他怀着中兴希望编了《甲申纪事》一书。清兵南下，他怀念故国，辗转于浙闽之间，刊行《中兴伟略》诸书，宣传抗清。隆武二年即清顺治三年春忧愤而死，又有说是被清兵所杀。<br>《三言》所收录的作品，有宋元旧篇，也有明代新作和冯梦龙拟作，但已一一难以辨别清楚。不过，无论旧篇或新作，都经其增删和润饰，使体制统一。 </p><h4 id="八、二拍"><a href="#八、二拍" class="headerlink" title="八、二拍"></a>八、二拍</h4><p>凌濛初(1580-1644)，明人，字玄房，号初成。浙江乌程人。18岁补廪膳生，55岁以优贡授上海县丞，63岁任徐州通判。明末农民军起，他与之对抗，最后呕血而死。<br>廪膳生：明清两代称由公家给以膳食的生员。<br>凌蒙初著作拟话本小说集《拍案惊奇》初刻和二刻（简称“二拍”）。“初刻”、“二刻”各40卷，其中“二刻”第23卷《大姊魂游完宿愿,小姨病起续前缘》与“初刻”重复。“二刻”的第40卷则是《宋公明闹元宵》杂剧。因此，“二拍”实有小说78篇。<br>凌蒙初是中国创作拟话本小说最多的一个作家。<br>它比《三言》逊色，盖因“沟中之断芜”难为巧手了。 </p><h4 id="九、聊斋志异"><a href="#九、聊斋志异" class="headerlink" title="九、聊斋志异"></a>九、聊斋志异</h4><p>蒲松龄(1640-1715)，清人，字留仙，一字剑臣，别号柳泉居士，自称异史氏，山东淄博蒲家庄人。<br>19岁初应童子试，以县、府、道三个第一名补博士弟子员，颇受施闰章的赏识，赞他“观书如月，运笔成风”，一时文名颇高。他在同乡学友李希梅家中读书时，“请订一籍，日诵一文焉书之，阅一经焉书之，作一艺、仿一贴焉书之。每晨兴而为之标日焉。庶使一日无功，则愧、则警、则汗涔涔下也”（蒲松龄《醒轩日课序》）。<br>虽一生刻苦好学，但自19岁之后，屡试不第，直到71岁高龄，才援例成为贡生。康熙五十四年农历正月二十二日，也就是在他的夫人去世的两年之后，依窗危坐逝世。<br>满腔愤气寄托在《聊斋志异》的创作中。此书创作从他年轻时开始，一直到暮年方才成书，“集腋为裘，妄续幽冥之录；浮白载笔，仅成孤愤之书。寄托如此，亦足悲矣！”<br>《聊斋志异》通行本16卷，共400余篇，后来续有发现，合计近500篇，是明清小说文言体中的唯一名著。鲁迅：“专集之最有名者”；郭沫若：“写鬼写妖高人一等，刺贪刺虐入骨三分”；老舍：“鬼狐有性格，笑骂成文章”。 </p><p>大江东去(寄王如水)·词·清·蒲松龄<br>天孙老矣，颠倒了、天下几多杰士。蕊宫榜放，直教那、抱玉卞和哭死。病鲤暴腮，飞鸿铩羽，同吊寒江水。见时相对，将从何处说起？<br>每每顾影自悲，可怜肮脏骨，销磨如此！糊眼冬烘鬼梦时，憎命文章难恃。数卷残书，半窗寒烛，冷落荒斋里。未能免俗，亦云聊复尔尔。 </p><h4 id="十、儒林外史"><a href="#十、儒林外史" class="headerlink" title="十、儒林外史"></a>十、儒林外史</h4><p>吴敬梓(1701-1754)，清人，字敏轩，一字粒民，晚年自号文木老人，又称秦淮寓客。他出身于书香世家。60年间，家族中有进士、举人等功名以及出仕的官员十四五人。<br>吴敬梓的生父吴雯延，自幼便被过继给长房吴霖起为嗣。吴霖起死后，近房中不少人觊觎遗产，乃至亲族冲入家中攫夺其财产。虽然最后他继承了遗产，但因争产之事深受刺激，开始挥霍 ，乡里传为“子弟戒”。<br>《儒林外史》的写作年代难以确定，但至少下半部是在南京写的。此外还创作了不少诗词文赋，部分结集在今存的《文木山房集》中。<br>《儒林外史》表面上写的是明代生活，实际上展示了一幅清朝社会的风俗画，讽刺官吏无能、豪绅贪吝、八股取士等。<br>《儒林外史》没有一个贯穿全书的主角，是生活流创作的先驱，是我国叙事文学中讽刺艺术的高峰。全书无一爱情故事，摆脱了传统小说才子佳人的香艳俗套。依靠对生活和人物性格的真实的艺术塑造，取得巨大的生命力。</p><h4 id="十一、红楼梦"><a href="#十一、红楼梦" class="headerlink" title="十一、红楼梦"></a>十一、红楼梦</h4><p>曹雪芹，清(1715-1763)名霑，字梦阮，号雪芹、又号芹圃、芹溪，祖籍辽阳，先世原是汉族，后为满洲正白旗“包衣”人。曾祖母孙氏曾做过康熙帝保姆，祖父曹寅做过康熙帝伴读和御前侍卫，后任江宁织造，兼任两淮巡盐监察御使。<br>曹寅病故，其子曹颙、曹頫先后继任江宁织造。他们祖孙三代四人担任此职达58年之久。<br>雍正初年，曹俯以“行为不端”、“骚扰驿站”和“亏空”罪名革职，家产抄没，曹雪芹便随着全家迁回北京居住。曹家从此一蹶不振，日渐衰微。<br>晚年，曹雪芹移居北京西郊，生活更加穷苦，“满径蓬蒿”，“举家食粥”，专心致志地从事《红楼梦》的修订。《红楼梦》是他“披阅十载，增删五次”，“字字看来皆是血，十年辛苦不寻常”的产物。<br>乾隆二十八年，幼子夭亡，令他极度的悲痛，到了这一年的除夕，终于因贫病无医而逝世，享年近五十岁。<br>小说《红楼梦》内容丰富，思想深刻，艺术精湛，把中国古典小说创作推向最高峰，在世界文学发展史上占有十分重要的地位。<br>《红楼梦》对青年影响尤大，贾、林、薛三人的爱情婚姻悲剧引起了那个时代渴求自由的青年们的共鸣，从前屡禁不绝。</p><p>第三十七回 秋爽斋偶结海棠社 蘅芜院夜拟菊花题<br>咏海棠·七律·贾探春(蕉下客)<br>斜阳寒草带重门，苔翠盈铺雨后盆。<br>玉是精神难比洁，雪为肌骨易销魂。<br>芳心一点娇无力，倩影三更月有痕。<br>莫谓缟仙能羽化，多情伴我咏黄昏。<br>第三十八回 林潇湘魁夺菊花诗，薛蘅芜讽和螃蟹咏。<br>种菊·七律·贾宝玉(怡红公子)<br>携锄秋圃自移来，篱畔庭前故故栽。<br>昨夜不期经雨活，今朝犹喜带霜开。<br>冷吟秋色诗千首，醉酹寒香酒一杯。<br>泉溉泥封勤护惜，好知井径绝尘埃。 </p><p>后代的《红楼梦》续书除高鹗外，还有：<br>1、《红楼圆梦》，异名：绘图金陵；十二钗后传，回数：30，自120回续起，作者：临鹤山人。刊本：嘉庆十九年红蔷阁写刻本；大连市图书馆收藏。<br>2、《红楼梦影》，回数：24，自120回续起，作者：顾春。刊本：光绪三年聚珍堂活字印本，辽宁省图书馆藏。<br>3、《红楼幻梦》，异名：幻梦奇缘，回数：24，自97回续起，作者：花月痴人。刊本：道光二十三年疏影斋刊本，辽宁省图书馆藏。<br>4、《绮楼重梦》，异名：红楼续梦；蜃楼情梦；新红楼梦，回数：48，自120回续起，作者：王兰沚。刊本：初刊本为嘉庆四年则园漫士叙本，原书未见，仅存书目。现存较早刊本为嘉庆十年瑞凝堂本。北京大学图书馆藏。<br>5、《补红楼梦》，异名：补石头记，回数：48，自120回续起，作者：嫏环山樵。刊本：嘉庆二十五年刊本，北京师范大学图书馆藏。<br>6、《红楼梦补》，异名：红楼姊妹篇，回数：48，自97回续起，作者：归锄子。刊本：嘉庆二十四年藤花榭刊本，香港大学冯平山图书馆藏。<br>7、《续红楼梦》，异名：秦续红楼梦，回数：30，自97回续起，作者：秦子忱。刊本：嘉庆四年抱瓮轩刊本，辽宁省图书馆藏。<br>8、《红楼真梦》，异名：石头记补，回数：64，自120回续起，作者：郭则沄。刊本：民国二十九年家印铅字本，辽宁省图书馆藏。<br>9、《红楼复梦》，回数：100，自120回续起，作者：陈少海。刊本：嘉庆四年刊本，英国皇家亚洲学会藏。<br>10、《续红楼梦新编》，异名：续红楼梦；增红楼梦；增补红楼梦；红楼重梦；海续红楼梦，回数：40，自120回续起，作者：海圃主人。刊本：嘉庆十年文秀堂刊本，天津师范大学图书馆藏。<br>11、《续红楼梦稿》，异名：续红楼梦，回数：20，自120回续起，作者：张曜孙。刊本：此书未终卷，稿本九册，周绍良藏。 </p><h4 id="十二、其他书目"><a href="#十二、其他书目" class="headerlink" title="十二、其他书目"></a>十二、其他书目</h4><p>明：《杨家府演义》作者不详；《海公案》李春编；《醒世姻缘传》西周生辑著；《龙图公案》安遥时编。<br>清：《隋唐演义》褚人获著；《说岳全传》钱彩著；《野叟曝言》夏敬渠著；《女仙外史》吕熊著；《绿野仙踪》李百川著；《说唐演义全传》作者不详；《镜花缘》李汝珍著；《东周列国志》余邵鱼撰。<br>清末：《海上花列传》韩邦庆著，是最著名的吴语小说，也是中国第一部方言小说。</p><h4 id="以上内容均来自褚宝增老师讲义"><a href="#以上内容均来自褚宝增老师讲义" class="headerlink" title="以上内容均来自褚宝增老师讲义"></a>以上内容均来自褚宝增老师讲义</h4></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;h4 id=&quot;一、小说的变迁&quot;&gt;&lt;a href=&quot;#一、小说的变迁&quot; class=&quot;headerlink&quot; title=&quot;一、小说的变迁&quot;&gt;&lt;/a&gt;一、小说的变迁&lt;/h4&gt;&lt;p&gt;小说的基本特征：以散体文的形式表现叙事性的内容，通过一定的故事情节对人物的关系、命运、行为、思想、情感、环境、心理进行具体的艺术描写。&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="古典文学" scheme="https://xtlei.github.io/categories/%E5%8F%A4%E5%85%B8%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="古典文学史" scheme="https://xtlei.github.io/tags/%E5%8F%A4%E5%85%B8%E6%96%87%E5%AD%A6%E5%8F%B2/"/>
    
      <category term="明清" scheme="https://xtlei.github.io/tags/%E6%98%8E%E6%B8%85/"/>
    
      <category term="小说" scheme="https://xtlei.github.io/tags/%E5%B0%8F%E8%AF%B4/"/>
    
  </entry>
  
  <entry>
    <title>中国古典文学史之元剧散曲</title>
    <link href="https://xtlei.github.io/2020/03/14/%E4%B8%AD%E5%9B%BD%E5%8F%A4%E5%85%B8%E6%96%87%E5%AD%A6%E5%8F%B2%E7%95%A5%E4%B9%8B%E5%85%83%E5%89%A7%E6%95%A3%E6%9B%B2/"/>
    <id>https://xtlei.github.io/2020/03/14/%E4%B8%AD%E5%9B%BD%E5%8F%A4%E5%85%B8%E6%96%87%E5%AD%A6%E5%8F%B2%E7%95%A5%E4%B9%8B%E5%85%83%E5%89%A7%E6%95%A3%E6%9B%B2/</id>
    <published>2020-03-14T13:43:07.887Z</published>
    <updated>2020-03-31T07:42:58.103Z</updated>
    
    <content type="html"><![CDATA[<html><font face="Times New Roman,宋体" size="4"><p><strong>公元1279年 南宋灭亡。<br>公元1368年 元朝灭亡。</strong><a id="more"></a></p><h4 id="一、杂剧的起兴"><a href="#一、杂剧的起兴" class="headerlink" title="一、杂剧的起兴"></a>一、杂剧的起兴</h4><p>从唐以前，民歌舞和各项表演艺术中虽然都有一些戏剧性质，却始终没有发展成真正性质的戏曲。从唐到宋金时期，是我国戏曲的形成期，唐代各种艺术都获得了高度的发展，从多方面推动了戏曲的诞生。“燕乐”的随之出现，加之变文、小说、传奇的产生和流行，为后来戏曲提供了丰富的题材。<br>北宋时在唐参军戏的基础上发展起来的杂剧和后来金院本都是戏曲的雏形。借鉴鼓子词、词话、诸宫调、影戏等优点，使杂剧趋向完善，艺术基础愈加坚实。<br>元杂剧的形成是我国历史上各种表演艺术发展的结果，同时也是时代的产物。金灭北宋，元灭金的过程，同时也是北方汉人反抗女真族、蒙古族的过程。在这种苦难的斗争中，要求有战斗性和群众性较强的文艺形式加以表现，而构成戏曲艺术的各种因素到这时已经过长期的酝酿而融为一体。<br>特别是元初，民族矛盾十分尖锐，又没有恢复科举制度，中下层文人的进仕道路严重缩小了，生活随之下降。除少数依附元朝外，大多数文人精力无处释放，部分文人便和民间艺人结合组成书会，对元杂剧的兴盛起到了推动作用。<br>宋金元城市经济发展为杂剧的兴盛准备了充裕的物质条件。<br>此外，元朝疆域广大，交通发达，密切了各民族之间的文化交流，特别是北方诸民族乐曲的传播，对杂剧的兴盛也有一定的作用。<br>元代有名姓可考的杂剧作家，有八十余人。作品有五百余种，元杂剧最兴盛的时期是在前期。<br>南方还是以诗词为主要文学形成时，北方就出现了关汉卿、王实甫等杂剧作家。杂剧的语言以北方民间口语为基础，吸收民间艺术营养，具有质朴自然，生动泼辣的特点。</p><p>杂剧的体载，首先是一本四折的形式，四折之外又可以加一、二个“楔子”。<br>杂剧有三个构成部分：宾白，唱词，科介。“白”有韵白、散白，“科介”其包括动作表情，武打，歌舞及音响效果等。押韵以当时北方话为准则，方式为全套通压一韵，但可四声通协。曲文中可加衬字。杂剧角色分为三大类：末、旦、净。不够完善的地方，如全剧只由主要演员独唱和一本限定四折等。</p><h4 id="二、关汉卿"><a href="#二、关汉卿" class="headerlink" title="二、关汉卿"></a>二、关汉卿</h4><p>元钟嗣成《录鬼簿》说他是大都人，原籍可能在祁州，号己斋叟，汉族。他是一位熟悉勾栏伎艺的戏曲家，“生而倜傥，博学能文，滑稽多智，蕴藉风流，为一时之冠”(《析津志》)。生年约在金宣宗贞佑、元光之间，卒于元成宗大德年间。晚年到过杭州，长期混迹于书会才人间。一生写了六十多种杂剧。<br>现传《感天动地窦娥冤》《赵盼儿风月救风尘》《包待制三勘蝴蝶梦》《杜蕊娘智赏金线池》《关大王单刀会》《温太真玉镜台》等多种。散曲现存小令57首，套数14套。<br>“驱梨园领袖，总编修帅首，捻杂剧班头”（元钟嗣成《录鬼簿》贾仲明挽关氏词）</p><p>关汉卿现存的杂剧，从思想内容看，大致可分为三类。<br><strong>第一类：揭露社会黑暗</strong><br>代表作为《感天动地窦娥冤》。结合元代的现实生活，写出了一部激动人心的悲剧。为我国的悲剧艺术提供了典型的范例。</p><p>二黄慢板(自窦娥冤)·杂剧·元·关汉卿<br>未开言思往事心中调张，禁大娘你容我表叙衷肠。实可恨张驴儿良心昧丧，买羊肚要害婆婆一命身亡。害人者反害已徒劳妄想，他的父吃羊肚篓时断肠。狗奸碱仗男子出言无状，他把我老婆婆扭到公堂。不招认实难受无情梭棒，无情拌棒，为此事替婆婆认罪承当。</p><p>滚绣球(自窦娥冤)·杂剧·元·关汉卿<br>有日月朝暮悬，有鬼神掌着生死权。天地也只合把清浊分辨，可怎生糊突了盗跖颜渊。为善的，受贫穷更命短，造恶的，享富贵又寿延。天地也做的个怕硬欺软，却原来也这般顺水推船。地也，你不分好歹何为地，天也，你错勘贤愚枉作天。哎，只落得两泪涟涟。</p><p><strong>第二类：描写下层妇女</strong><br>代表作有《赵盼儿风月救风尘》。《救风尘》是一部杰出的喜剧。长期风尘生活使她看透了有钱的子弟们所惯用的那套伎俩，并对他们保持着高度的警惕。因此当她知道结拜妹妹宋引章要嫁给周舍时，便再三忠告她。</p><p>胜葫芦(自救风尘)·杂剧·元·关汉卿<br>你道这子弟情肠甜似蜜，但娶到他家里，多无半载周年相弃掷。早努牙突嘴，拳椎脚踢，打得你哭啼啼。</p><p>幺篇(自救风尘)·杂剧·元·关汉卿<br>恁时节船到江心补漏迟，烦恼怨他谁?事要前思免后悔。我也劝你不得，有朝一日，准备着搭救你块望夫石。<br>但宋引章没有接受劝告，落得一进门便吃五十杀威棒，只得写信向赵盼儿求救，赵盼儿挺身而出。救出宋引章，并制服了周舍，收到了大快人心的喜剧效果。</p><p><strong>第三类：歌颂历史英雄</strong><br>以《关大王单刀会》成就最高。剧中主角关羽的出场在第三折，但第一、二折已通过乔国老和司马徽的口渲染了他的英雄业绩和盖世威风，造成了强烈的戏剧气氛。</p><p>驻马听(自单刀会)·杂剧·元·关汉卿<br>水涌山叠。年少周郎何处也。不觉的灰飞烟灭。可怜黄盖转伤嗟。破曹的樯橹一时绝。鏖兵的江水由然热。好叫我情惨切。(云)这也不是江水。(唱)二十年流不尽的英雄血。</p><p>金盏儿(自单刀会)·杂剧·元·关汉卿<br>他上阵处赤力力三绺美髯飘。雄赳赳一丈虎躯摇。恰便似六丁神簇捧一个活神道。那敌军若是见了，唬的他七魄散，五魂消。(云)你若和他厮杀呵。(唱)你则索多披上几副甲，剩穿上几层袍。便有百万军当不住他不刺刺千里追风骑，你便有千员将闪不过明明偃月三停刀。</p><p>京剧《甘露寺》<br>劝千岁杀字休出口，老臣与主说从头。刘备本是靖王的后，汉帝玄孙一脉留。他有个二弟汉寿亭侯，青龙偃月神鬼皆愁；白马坡前诛文丑，在古城曾斩过老蔡阳的头。他三弟翼德威风有，丈八蛇矛惯取咽喉；鞭打督邮他气冲牛斗，虎牢关前战温侯；当阳桥前一声吼，喝断了桥梁水倒流。他四弟子龙常山将，盖世英雄冠九州；长坂坡救阿斗，杀得曹兵个个愁。这一班武将哪个有？还有诸葛用计谋。你杀刘备不要紧，他弟兄闻知怎肯罢休！若是兴兵来争斗，曹操坐把渔利收。我扭转回身奏太后，将计就计结鸾俦。 </p><p>京剧《空城计》诸葛亮唱段：<br>我本是卧龙岗散淡的人，凭阴阳如反掌保定乾坤。先帝爷下南阳御驾三请，算就了汉家业鼎足三分。官封到武乡侯执掌帅印，东西征南北剿博古通今。周文王访姜尚周室大振，汉诸葛怎比得前辈的先生。闲无事在敌楼我亮一亮琴音，我面前缺少个知音的人。</p><h4 id="三、王实甫"><a href="#三、王实甫" class="headerlink" title="三、王实甫"></a>三、王实甫</h4><p>王实甫，大都人，名德信，汉族。生卒年与生平事迹不详。可能由金入元。 </p><p>明贾仲明：“风月营密匝匝列旌旗，莺花寨明颩颩排剑戟，翠红乡雄赳赳施谋智。作词章风韵美，士林中等辈伏低。新杂剧，旧传奇，《西厢记》天下夺魁。” </p><p>著有杂剧十三种，以《西厢记》最为著名。五本二十一折。</p><p>叨叨令(自西厢记长亭送别)·杂剧·元·王实甫<br>见安排着车儿、马儿，不由人熬熬煎煎的气。有什么心情花儿、靥儿，打扮的娇娇滴滴的媚。准备着被儿、枕儿，则索昏昏沉沉的睡。从今后衫儿、袖儿，都揾做重重叠叠的泪。兀的不闷杀人也么哥，兀的不闷杀人也么哥。久已后书儿、信儿，索与我恓恓惶惶的寄。 </p><h4 id="四、白朴"><a href="#四、白朴" class="headerlink" title="四、白朴"></a>四、白朴</h4><p>白朴（1226-1306?），原名恒，字仁甫，后改名朴，字太素，号兰谷。汉族，祖籍隩州。<br>白朴出身官僚士大夫家庭，父亲白华为金宣宗三年进士，官至枢密院判。白家与元好问父子为世交，过从甚密，常以诗文相往来。<br>白朴对蒙古统治者充满了厌恶，因此放弃了官场名利的争逐，而以亡国遗民自适，以词曲为专门之业，以宣泄自己胸中的块垒。<br>元世祖中统二年，元世祖命各路宣抚使举文学才识可以从考者，以听擢用，时以河南路推荐白朴出仕，被他谢绝，弃家南游汉口、九江、洞庭。到元世祖至元十七年在金陵定居。主要在江南的杭州、扬州一带游历，直到81岁时，还重游扬州。而后，他的行踪就无从寻觅了。<br>白朴的杂剧善于利用历史题材，敷演故事，因旧题，创新意，词采优美，情意深切绵长。与关汉卿、马致远、郑光祖并称为元曲四大作家。代表作主要有《唐明皇秋夜梧桐雨》《裴少俊墙头马上》《董秀英花月东墙记》等15种剧本。</p><p>鸳鸯煞(自梧桐雨)·杂剧·元·白朴<br>黄埃散漫悲风飒，碧云黯淡斜阳下；一程程水绿山青，一步步剑岭巴峡，唱道感叹情长，凄惶泪洒。早得升遐，休休却是今生罢。这个不得已的官家，哭上逍遥玉骢马。</p><h4 id="五、马致远"><a href="#五、马致远" class="headerlink" title="五、马致远"></a>五、马致远</h4><p>马致远(1250-1321)，号“东篱”，大都人，汉族。是当时在北方流行的全真教的信徒。<br>青年仕途坎坷，中年中进士。晚年不满时政，隐居田园。<br>马致远早年即参加了杂剧创作，是“贞元书会”的主要成员，与文士王伯成、李时中，艺人花李郎、红字李二都有交往，也是当时最著名的“四大家”之一。有“曲状元”之誉。<br>所做杂剧以《汉宫秋》为其代表作，另有《荐福碑》《岳阳楼》《青衫泪》等15种。散曲120多首，有辑本《东篱乐府》。<br>马致远写《汉宫秋》时，暗藏爱国反元深意。 </p><p>殿前欢(自汉宫秋)·杂剧·元·马致远<br>则什么留下舞衣裳，被西风吹散旧时香。我委实怕宫车再过青苔巷，猛到椒房，那一会想菱花镜里妆，风流相，兜的又横心上。看今日昭君出塞，几时似苏武还乡？</p><p>得胜令(自汉宫秋)·杂剧·元·马致远<br>他去也不沙架海紫金梁，枉养着那边庭上铁衣郎。您也要左右人扶侍，俺可甚糟糠妻下堂！您但提起刀枪，却早小鹿儿心头撞。今日央及煞娘娘，怎做的男儿当自强！ </p><h4 id="六、郑光祖"><a href="#六、郑光祖" class="headerlink" title="六、郑光祖"></a>六、郑光祖</h4><p>郑光祖，字德辉，平阳襄陵人，汉族。生卒不详，是元杂剧后期的重要作家。元钟嗣成《录鬼簿》说他曾“以儒补杭州路吏，为人方直，不妄与人交。名闻天下，声彻闺阁，伶伦辈称郑老先生者，皆知为德辉也”。他写过杂剧十八种。今存《迷青琐倩女离魂》、《刍梅香翰林风月》、《醉思乡王粲登楼》等八种。<br>《倩女离魂》是他的代表作，本事出于唐李玄佑的传奇《离魂记》。 </p><p>上小楼(自倩女离魂)·杂剧·元·郑光祖<br>则道你辜恩负德，你原来得官及第。你直叩丹墀，夺得朝章，换却白衣。觑画仪，比向日、相别之际，更有三千丈五陵豪气。(正末云)小姐，我去也。(下)(正旦醒科，云)分明见王生，说得了官也，醒来却是南柯一梦。(唱) </p><p>东原乐(自倩女离魂)·杂剧·元·郑光祖<br>你若是赴御宴琼林罢。媒人每拦着马。高挑起渲染佳人丹青画。卖弄他生长在王侯宰相家。你恋着那奢华。你敢新婚燕尔在他门下。</p><h4 id="七、高明"><a href="#七、高明" class="headerlink" title="七、高明"></a>七、高明</h4><p>高明(1305?-1371?)，字则诚，号菜根道人，汉族，浙江瑞安人。<br>高明青年时期用世之心很盛，元顺帝至正五年考中进士，历任处州录事、江浙行省丞相掾、福建行省都事等职。为官清明练达。关心民间疾苦，不屈权势，处州期满离任时，百姓曾为他立碑。由于数忤权贵，晚年退居于明州，以词曲自娱。相传明初太祖朱元璋慕其名，遣使征召，他佯狂不出，不久病卒。<br>南戏《琵琶记》是高明得以名扬后世的代表作，成为南戏创作的范本，获得“南曲之宗”的称誉。 </p><p>孝顺歌(自琵琶记糟糠自厌)·杂剧·元·高明<br>糠和米本是相依倚，被簸扬作两处飞。一贱与一贵。好似奴家与夫婿，终无见期。丈夫，你便是米呵，米在他方没处寻；奴家恰便似糠呵，怎的把糠来救得人饥馁；好似儿夫出去，怎的敎奴供饍得公婆甘旨。</p><h4 id="八、散曲综述"><a href="#八、散曲综述" class="headerlink" title="八、散曲综述"></a>八、散曲综述</h4><p>从中晚唐以来，经过长期酝酿，到了宋金对立时期，又吸收了一些民间兴起的曲词和女真、蒙古等少数民族乐曲，逐渐形成了一种新的诗歌形式，这就是当时流传在北方的散曲，也称北曲。<br>散曲包括小令和套数两种主要形式。它和词不同的地方是用韵加密了，几乎每句都要押韵，而且平、上、去三声互叶，不象诗词一般平仄韵不能通押。<br>套数沿自诸宫调，它是由两首以上同一宫调的曲子相联而成的组曲，一般都有尾声，并且要一韵到底。<br>风格特点：大量运用俚语俗谚，极少雕饰，幽默诙谐，气韵生动。<br>最后也是最重要的一点，散曲是可以在本调之外加衬字，如：<br>醉太平·散曲·元·张可久<br>风流贫最好。村沙富难交。拾灰泥补砌了旧砖窑。开一个教乞儿市学，裹一顶半新不旧乌纱帽。穿一领半长不短黄麻罩。系一条半联不断皂环绦。做一个穷风月训导。<br>去掉衬字后为：<br>风流最好。村沙难交。灰泥补砌旧砖窑。教乞儿市学，半新不旧乌纱帽。半长不短黄麻罩。半联不断皂环绦。风月训导。</p><h4 id="九、张养浩"><a href="#九、张养浩" class="headerlink" title="九、张养浩"></a>九、张养浩</h4><p>张养浩（1269-1329），字希孟，号云庄，济南人，汉族。诗、文兼擅，而以散曲著称。19岁被荐为东平学正，历官堂邑县尹、监察御史、翰林学士、礼部尚书、参议中书省事。于英宗至治二年辞官家居，此后屡召不赴。文宗天历二年，关中大旱，特拜陕西行台中丞，遂“散其家之所有”“登车就道”（《元史》本传），星夜奔赴任所。到任四月，劳瘁而卒。追封滨国公，谥文忠。<br>张养浩居官清正，敢于犯颜直谏。在堂邑县，抑制豪强，赈灾济贫。拜监察御史之后，他绳纠贪邪，荐举廉正，弹劾不避权贵，举荐不疏仇怨，“入焉与天子争是非，出焉与大臣辨可否”（《风宪忠告》），蹈厉风发，“道之所在，死生以之”（同上）。其门人黄溍说他“力排权奸，几蹈祸而不悔”（《滨国公张文忠祠堂碑》）。</p><p>山坡羊（潼关怀古）·小令·元·张养浩<br>峰峦如聚，波涛如怒，山河表里潼关路。望西都，意踌躇。伤心秦汉经行处，宫阙万间都做了土。兴，百姓苦；亡，百姓苦。</p><h4 id="十、乔吉"><a href="#十、乔吉" class="headerlink" title="十、乔吉"></a>十、乔吉</h4><p>乔吉(?～1345)，一称乔吉甫，字梦符，号笙鹤翁，又号惺惺道人，太原人，流寓杭州。杂剧、散曲作家。<br>元钟嗣成在《录鬼簿》说他“美容仪，能辞章，以威严自饬，人敬畏之”，又作吊词云：“平生湖海少知音，几曲宫商大用心。百年光景还争甚？空赢得，雪鬓侵，跨仙禽，路绕云深。”<br>乔吉的散曲以婉丽见长，精于音律，工于锤炼，喜欢引用或融化前人诗句。</p><p>折桂令(荆溪即事)·散曲·元·乔吉<br>问荆溪溪上人家，为甚人家，不种梅花。老树支门，荒蒲绕岸，苦竹圈笆。庙不灵狐狸弄瓦，官无事鸟鼠当衙。白水黄沙，倚遍阑干，数尽啼鸦。</p><h4 id="十一、散曲欣赏"><a href="#十一、散曲欣赏" class="headerlink" title="十一、散曲欣赏"></a>十一、散曲欣赏</h4><p>双调拨不断(大鱼)·散曲·元·王和卿<br>胜神鳌，夯风涛，脊梁上轻负着蓬莱岛。万里夕阳锦背高，翻身犹恨东洋小。太公怎钓?</p><p>双调潘妃曲·散曲·元·商挺<br>带月披星担惊怕，久立纱窗下，等候他。蓦听得门外地皮儿踏，则道是冤家，原来风动荼縻架。</p><p>双调沉醉东风·散曲·元·卢挚<br>对酒问人生几何，被无情日月消磨。炼成腹内丹，泼煞心头火,葫芦提醉中闲过，万里云山入浩歌，一任傍人笑我。</p><p>中吕山坡羊·散曲·元·陈英<br>晨鸡初叫，昏鸦争噪。那个不去红尘闹？路遥遥，水迢迢，功名尽在长安道。今日少年明日老。山，依旧好；人，憔悴了。</p><p>双调大德歌(夏)·散曲·元·关汉卿<br>俏冤家，在天涯，偏那里绿杨堪系马。困坐南窗下，数对清风想念他。蛾眉淡了教谁画？瘦岩岩羞戴石榴花。</p><p>南吕一枝花(不伏老)·散曲·元·关汉卿<br>我却是个蒸不烂，煮不熟，捶不匾，炒不爆，响当当一粒铜豌豆。子弟每，谁教你钻入他锄不断，砍不下，解不开，顿不脱，慢腾腾千层锦套头。我玩的是梁园月，饮的是东京酒。赏的是洛阳花，攀的是章台柳。我也会吟诗，会篆籀，会弹丝，会品竹。我也会唱鹧鸪，舞垂手，会打围，会蹴踘，会围棋，会双陆。你便是落了我牙，歪了我口，瘸了我腿，折了我手，天与我这儿般儿歹症侯，尚兀自不肯休。只除是阎王亲令唤，神鬼自来勾，三魂归地府，七魄丧冥幽，那其间才不向烟花路儿上走。</p><p>仙吕寄生草(饮)·散曲·元·白朴<br>长醉后方何碍，不醒时甚思。糟腌两个功名字，醅瀹千古兴亡事，曲埋万丈虹霓志。不达时皆笑屈原非，但知音尽说陶潜是。</p><p>中吕十二月过尧民歌(别情)·散曲·元·王实甫<br>自别后遥山隐隐，更那堪远水粼粼。见杨柳飞绵滚滚，对桃花醉脸醺醺。透内阁香风阵阵，掩重门暮雨纷纷。<br>怕黄昏忽地又黄昏，不销魂怎地不销魂。新啼痕压旧啼痕，断肠人忆断肠人。今春香肌瘦几分？搂带宽三寸。 </p><p>双调夜行船(秋思)·散曲·元·马致远<br>蛩吟罢一觉才宁贴。鸡鸣时万事无休歇。争名利何年是彻。看密匝匝蚁排兵，乱纷纷蜂酿蜜，闹穰穰蝇争血。裴公绿野堂，陶令白莲社。爱秋来时那些。和露摘黄花，带霜烹紫蟹，煮酒烧红叶。想人生有限杯，浑几个重阳节。嘱付我顽童记者。便北海探吾来，道东篱醉了也。</p><p>高祖还乡(选段)·散曲·元·睢景臣<br>二煞：你身须姓刘，你妻须姓吕，把你两家儿根脚从头数。你本身做亭长耽几盏酒，你丈人教村学读几卷书。曾在俺庄东住。也曾与我喂牛切草，拽坝扶锄。<br>一煞：春采了俺桑，冬借了俺粟。零支了米麦无重数。换田契强秤了麻三秤，还酒债偷量了豆几斛。有甚胡涂处。明标着册历，见放着文书。<br>尾：少我的钱，差发内旋拨还。欠我的粟，税粮中私准除。只道刘三，谁肯把你揪捽住。白什么改了姓，更了名，唤作汉高祖。</p><p>醉太平·散曲·元·无名氏<br>堂堂大元，奸佞专权。开河变钞祸根源，惹红巾万千。官法滥，刑法重，黎民怨。人吃人，钞买钞，何曾见。贼做官，官做贼，混贤愚。哀哉可怜！</p><p>醉太平(讥贪小利者)·散曲·元·无名氏<br>夺泥燕口，削铁针头，刮金佛面细搜求：无中觅有。鹌鹑嗉里寻豌豆，鹭鸶腿上劈精肉，蚊子腹内刳脂油。亏老先生下手！</p><h4 id="以上内容均来自褚宝增老师讲义"><a href="#以上内容均来自褚宝增老师讲义" class="headerlink" title="以上内容均来自褚宝增老师讲义"></a>以上内容均来自褚宝增老师讲义</h4></font></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;font face=&quot;Times New Roman,宋体&quot; size=&quot;4&quot;&gt;

&lt;p&gt;&lt;strong&gt;公元1279年 南宋灭亡。&lt;br&gt;公元1368年 元朝灭亡。&lt;/strong&gt;&lt;/p&gt;&lt;/font&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="古典文学" scheme="https://xtlei.github.io/categories/%E5%8F%A4%E5%85%B8%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="古典文学史" scheme="https://xtlei.github.io/tags/%E5%8F%A4%E5%85%B8%E6%96%87%E5%AD%A6%E5%8F%B2/"/>
    
      <category term="元朝" scheme="https://xtlei.github.io/tags/%E5%85%83%E6%9C%9D/"/>
    
      <category term="元剧" scheme="https://xtlei.github.io/tags/%E5%85%83%E5%89%A7/"/>
    
      <category term="散曲" scheme="https://xtlei.github.io/tags/%E6%95%A3%E6%9B%B2/"/>
    
  </entry>
  
</feed>
